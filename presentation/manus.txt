
- Overview
    + Background
    + The Case
    + Approach & Design Choices
    + Implementation
    + Examples  Results
    + Evaluation
    + Related & Future Work
    + Conclusion

- Background
    + Proofs
        proofs are an important part of mathematics
        two kinds of proofs:
            informal proofs, natural language, by humans for humans
            formal proofs, formal language, hard for humans easy for computers
        we can tranfsorm informal proofs into formal proofs (formalization)
        using computers  proof assistants we can check formal proofs (verification)
        we can also extract programs from formal proofs


    + Type Theory
        foundation of mathematics
        every object has a type, must know its construction!
        provides us with rules of inference for manipulating types  objects
        dependent types:
        types can depend on objects
        gives us more expressive power, especially when using propositions as types
        we can model existential and universal quantification from First Order Logic

    + Propositions as types
        everything can be a type, including propositions
        since we must know the construction of a type, we must know the construction of a proposition
        proofs are objects of a proposition type
        also means that proofs are programs, i.e. they can be executed

    + Proof assistants
        software tools for constructing and verifying formal proofs
        based on concepts from type theory, propositions as types
        Coq, Agda, Lean, etc.
        extraction of programs

- The Case in Question

    + Overview of the case
        two problems in lattice theory solved by Bezem & Coquand, summarized:
            * the uniform word problem for an equational theory of semilattices with
              one inflationary endomorphism can be solved in polynomial time
            * loop-checking in a type system with universe-level constraints can be done
              in polynomial time
        given this, we want to answer these questions:
            1. are the results from Bezem & Coquand correct?
            2. is it feasible to formalize such complex proofs as in Bezem & Coquand?
            3. is the formalization process worth the effort, i.e. what do we gain from it?

- Relevant parts of the paper

    Theory:
        join-semilattices:
            partially ordered set where any two elements have a least upper bound,
            called their join, denoted $lor$
        inflationary endomorphism:
            function that maps an element to itself or to a greater element in the ordered set,
            denoted $_^x$
        semilattice p1:
            set V of variables and set C of constratins.
            for a semilattice term t and k in N, t + 0 = t and t + 1 = t^+.
            a term over V has the form x_1 + k_1 v ... v x_m + k_m.
        Horn clauses:
            propositional clauses A -> b with a non-empty body A
            and a conclusion b. Atom are of the form x + k.
        semilattice p2:
            a constraint over V has the form s = t, where s and t are terms over V.
            for a constraint s = t, we can generate Horn claues by replacing join by conjuction
            , denoted "," and >= by implication.
            the set of all generated clauses from a constraint is denoted S_s=t

        since provability in semilattice theoy is shown to be equivalent to provability
        in Horn clauses, we can continue with Horn clauses moving forward.

        we define closure under shifitng upwards as follows:
            if A -> b is in a set of clauses, then so is
            A + 1 -> b + 1, where A + 1 is every atom in A shifted upwards by 1.

        S_C' is the smalles subset of S_C that is closed under shifting upwards
        S_C'|W is the set of clauses in S_C' that contain only variables from W
        S_C'vW is the set of clauses in S_C' with conclusion over W

        A model of a set of clauses S_C' is defined by a function f from V to Ninfty

    Lemma 3.1: makes provability in semilattice theory decidable

    Theorem 3.2: we can compute the least model of a set of clauses S_C'

    Lemma 3.3: solves special case of Theorem 3.2


- Approach & Design Choices
    + Simplifications for the sake of time
        incomplete formal proofs:
            purely logical, not interesting,
            mosly use for sets since they are a pain to work with
        leaving out formal proof for Lemma 3.3:
            we only give formulation
            proof is long and complex
            is still sufficent for many cases
        proof of minimality of least model:
            we do not prove minimality of our model
            our model is however minimal but not formally proven to be

    + Modeling finite sets in Coq
        + List & ListSet
            traditional approach using lists
            type polymorphic
            obvious problems due to lists being ordered and having duplicates
            we can combat this with NoDup and set functions from ListSet
            some of these functions require decidability proof, usually ez af

        + MSetWeakList
            a lot more complicated
            gives a functor which transforms a given module where some properties of a type are needed to be specified
                and gives back a module with a set of functions for that type
            is a lot of work if we need to use it for multiple different types
            probably the way to go if you are better with Coq

        + Ensembles
            only has inductive propositions about if an element is in a set or not
            cannot actually "build" a set, only determine if a given element is in a set
            thus, cannot reason about length of a set, ergo useless

- Implementation
    + Data types

        Atom:
        Clause:
        Ninfty: either a natural number fin n or infinity infty
        Frontier: string -> Ninfty


        check if satisfied by frontier: atom_true, clause_true
        shift by n upwards: shift_atom, shift_clause
        satisfied for all shifts: all_shifts_true

                                    decidable by Lemma 3.1
                                    will be used later to determine model
                
Functions  predicates

[fragile]
    Implementation – Functions  predicates

    
        sub_model Cs V W f : bool            For each clause in Cs, checks three conditions:
            
                                    variable in conclusion of clause is not in W
                                    some variable in the premise of the clause is not in V
                                    the clause is true for all shifts
                        If any of these are true for all clauses, f is a model of Cs.

            Can handle all of ,  and .
        sub_forward Cs V W f : set string * Frontier            For each clause in Cs, checks the same as sub_model,
            and adds variable in conclusion to set of "improvable" variables if 1,2,3 are all false.
            Returns tuple where first value is the set of improvable variables,
            and the second value is a new frontier that is incremented by one for each variable in the set.
    
[fragile]
    Implementation – Functions  predicates

    
        geq V g f : bool            Checks if frontier g is greater than or equal to frontier f for all variables in V.
        ex_lfp_geq Cs V W f : Set :=                  exists g : Frontier, geq V g f / sub_model Cs V W g.    
Theorem 3.2

[fragile]
    Implementation – Theorem 3.2

    Theorem thm_32 :      forall n m Cs V W f,        incl W V ->        Datatypes.length (nodup string_dec V) <= n ->        Datatypes.length          (set_diff string_dec            (nodup string_dec V)            (nodup string_dec W)        ) <= m <= n ->        ex_lfp_geq Cs (nodup string_dec W) (nodup string_dec W) f ->        ex_lfp_geq Cs (nodup string_dec V) (nodup string_dec V).
Theorem 3.2 proof overview

    Implementation – Theorem 3.2 proof overview

    
                    Proof by primary induction on n (length of V),
            and secondary induction on m (length of V - W).
            Both base cases and induction step of n relatively easy,
            induction step of m by far most complex.

                    In induction step of m, we distinguish between three cases:
            
                                    
                                    
                                    ,
                    apply primary and secondary induction hypotheses,
                    and apply Lemma 3.3
                

Examples  Results
Extraction and output


    Extraction and output examples

    
                    We can extract formal proofs to Haskell code,
            and run Theorem 3.2 on a set of clauses.
                    :
            Example Cs := [ ["a" & 0]  > "b" & 1; ["b" & 1]  > "c" & 2 ]            thm_32 Cs "a" => Fin 0            thm_32 Cs "b" => Fin 1            thm_32 Cs "c" => Fin 2                    :
            Example Cs_loop := [ ["a" & 0]  > "a" & 1 ]            thm_32 Cs_loop "a" => Infty    

Real-world example  limitations


    Real-world example  limitations

    
                    We can use Theorem 3.2 algorithm to check type universe level consistency in Coq,
            which Coq does when type-checking.
                    The Coq Command Print Universes gives us a list of universe constraints,
            can be translated to our syntax. In testing this produced correct
            type universe levels for over 5000 constraints.
                    Algorithm does not always work due to Lemma 3.3 not formally proven,
            e.g. fails when extending first example with
            Example Cs := [ (*...*) ["c" & 2]  > "d" & 3 ].    

Related  Future Work
Related work


    Related work

    Ongoing effort by Matthieu Sozeau, Coq Team to implement version of algorithm for use
    in universe consistency checking in Coq.
    Main focus on speed, and only supports clauses of the form
    , where .



- Future work



    
                    Complete proofs of remaining logical lemmas
                    Formal proof of Lemma 3.3
                    Prove minimality of model in Theorem 3.2
    

Evaluation  Conclusion


    Evaluation  Conclusion

    
        Are the results correct?
            
                we have not formalized every part of results,
                    and we have simplified some proofs
                but, with a full formal proof of Theorem 3.2, we can be very confident that the results are correct
                    Is it feasible to formalize such complex proofs?
            
                by our effort, yes
                could be done faster and/or better with more experience
                    Is the formalization process worth the effort?
            
                                    we gain a usable prototype
                                    can be used as a starting point for more efficient implementations

