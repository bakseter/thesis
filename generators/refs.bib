@article{mbezem,
    title = "Loop-checking and the uniform word problem for join-semilattices with an inflationary endomorphism",
    journal = "Theoretical Computer Science",
    year = "2022",
    issn = "0304-3975",
    doi = "https://doi.org/10.1016/j.tcs.2022.01.017",
    url = "https://www.sciencedirect.com/science/article/pii/S0304397522000317",
    author = "Marc Bezem and Thierry Coquand",
    keywords = "Join-semilattices with one inflationary endomorphism, Uniform word problem, Loop-checking, Decidability",
    abstract = "We solve in polynomial time two decision problems that occur in type checking when typings depend on universe level constraints."
}

@book{bpierce,
    author       =   {Benjamin C. Pierce and
                      Arthur Azevedo de Amorim and Chris Casinghino and
                      Marco Gaboardi and
                      Michael Greenberg and
                      Cătălin Hriţcu and
                      Vilhelm Sjöberg and
                      Brent Yorgey},
    editor       =   {Benjamin C. Pierce},
    title        =   "Logical Foundations",
    series       =   "Software Foundations",
    volume       =   "1",
    year         =   "2022",
    publisher    =   "Electronic textbook",
    url          =   "https://softwarefoundations.cis.upenn.edu/lf-current/index.html",
    note         =   "Version 6.2"
}

@misc{rkhamsi,
    title = "Mathematical proofs are getting harder to verify",
    author = "Roxanne Khamsi",
    year = "2006",
    keywords = "Mathematics, Proof verification",
    url = "https://www.newscientist.com/article/dn8743-mathematical-proofs-getting-harder-to-verify",
    note = "Accessed: 2023-18-01"
}

@misc{cgallina,
    title = "The {Gallina} specification language",
    author = "The Coq Team",
    keywords = "Coq, Gallina, specification language",
    url = "https://coq.github.io/doc/v8.9/refman/language/gallina-specification-language.html",
    note = "Accessed: 2023-03-21"
}

@conference{cltac,
    title = "A {Tactic} {Language} for the {System} {Coq}",
    author = "D. Delahaye",
    booktitle = "Proceedings of Logic for Programming and Automated Reasoning (LPAR), Reunion Island",
    series = "Lecture Notes in Computer Science",
    year = "2000",
    month = "November",
    volume = "1955",
    pages = "85--95",
    organization = "Springer-Verlag",
    url = "https://www.lirmm.fr/%7Edelahaye/papers/ltac%20(LPAR%2700).pdf"
}

@misc{cide,
    title = "{CoqIDE}",
    author = "The Coq Team",
    keywords = "Coq, CoqIDE, GUI",
    url = "https://coq.inria.fr/refman/practical-tools/coqide.html",
    note = "Accessed: 2023-03-21"
}

@misc{cssr,
    title = "The {SSREFLECT} proof language",
    author = "Georges Gonthier and Assia Mahboubi and Enrico Tassi",
    keywords = "Coq, SSREFLECT, proof language",
    url = "https://coq.inria.fr/refman/proof-engine/ssreflect-proof-language.html",
    note = "Accessed: 2023-03-21"
}

@article{ams:formal-proof,
    title = "Formal {Proof}",
    journal = "Notices of the American Mathematical Society",
    author = "Thomas C. Hales",
    keywords = "Formalization, Proofs",
    year = 2008,
    volume = "55",
    number = "11",
    pages = "1370--1380",
    url ="https://www.ams.org/notices/200811/200811FullIssue.pdf"
}

@misc{coqgithub,
    title = "Universes loop checking with clauses",
    author = "Matthieu Sozeau",
    keywords = "Coq, pull request, loop checking",
    url = "https://github.com/coq/coq/pull/16022",
    note = "Accessed: 2023-05-01"
}

@misc{cintro,
    title = "A short introduction to {Coq}",
    author = "The Coq Team",
    keywords = "Coq, proof assistant",
    url = "https://coq.inria.fr/a-short-introduction-to-coq",
    note = "Accessed: 2023-01-18"
}

@misc{coqlist,
    title = "{Library} {Coq.Lists.ListSet}",
    author = "The Coq Team",
    keywords = "Coq, finite sets as lists",
    url = "https://coq.inria.fr/library/Coq.Lists.ListSet.html",
    note = "Accessed: 2023-05-11"
}

@misc{coqlistset,
    title = "{Library} {Coq.Lists.List}",
    author = "The Coq Team",
    keywords = "Coq, lists",
    url = "https://coq.inria.fr/library/Coq.Lists.List.html",
    note = "Accessed: 2023-05-11"
}

@misc{coqmsetweaklist,
    title = "{Library} {Coq.MSets.MSetWeakList}",
    author = "The Coq Team",
    keywords = "Coq, lists without redundancy",
    url = "https://coq.inria.fr/library/Coq.MSets.MSetWeakList.html",
    note = "Accessed: 2023-05-11"
}

@misc{coqensembles,
    title = "{Library} {Coq.Sets.Ensembles}",
    author = "The Coq Team",
    keywords = "Coq, sets",
    url = "https://coq.inria.fr/library/Coq.Sets.Ensembles.html",
    note = "Accessed: 2023-05-11"
}

@misc{coqdatatypes,
    title = "{Library} {Coq.Init.Datatypes}",
    author = "The Coq Team",
    keywords = "Coq, datatypes",
    url = "https://coq.inria.fr/library/Coq.Init.Datatypes.html",
    note = "Accessed: 2023-05-11"
}

@misc{cic,
    title = "Calculus of {Inductive} {Constructions}",
    author = "The Coq Team",
    keywords = "Calculus of inductive constructions, type theory, Coq",
    url = "https://coq.github.io/doc/v8.9/refman/language/cic.html#calculusofinductiveconstructions",
    note = "Accessed: 2023-05-01"
}

@inproceedings{agdatut,
    author="Bove, Ana and Dybjer, Peter and Norell, Ulf",
    editor="Berghofer, Stefan and Nipkow, Tobias and Urban, Christian and Wenzel, Makarius",
    title="A {Brief} {Overview} of {Agda} -- {A} {Functional} {Language} with {Dependent} {Types}",
    booktitle="Theorem Proving in Higher Order Logics",
    year="2009",
    publisher="Springer Berlin Heidelberg",
    address="Berlin, Heidelberg",
    pages="73--78",
    abstract="We give an overview of Agda, the latest in a series of dependently typed programming languages developed in Gothenburg. Agda is based on Martin-L{\"o}f's intuitionistic type theory but extends it with numerous programming language features. It supports a wide range of inductive data types, including inductive families and inductive-recursive types, with associated flexible pattern-matching. Unlike other proof assistants, Agda is not tactic-based. Instead it has an Emacs-based interface which allows programming by gradual refinement of incomplete type-correct terms.",
    isbn="978-3-642-03359-9"
}

@conference{lean,
    title = "The {Lean} {Theorem} {Prover} (system description)",
    author = {Leonardo de Moura and Soonho Kong and Jeremy Avigad and Floris van Doorn and Jakob von Raumer},
    booktitle = "25th International Conference on Automated Deduction (CADE-25), Berlin, Germany",
    year = "2015",
    keywords = "Lean, theorem prover",
    url = "https://leanprover.github.io/papers/system.pdf"
}

@inproceedings{coqextroverview,
    author = {Pierre Letouzey},
    title = {{Coq Extraction, an Overview}},
    booktitle = {{Logic and Theory of Algorithms, Fourth Conference on Computability in Europe, CiE 2008}},
    editor = {A. Beckman and C. Dimitracopoulos and B. L{\"o}we},
    volume = 5028,
    publisher =    {Springer-Verlag},
    series =       {Lecture Notes in Computer Science},
    year = 2008,
    url = {https://www.irif.fr/~letouzey/download/letouzey_extr_cie08.pdf}
}

@inproceedings{coqextrnew,
    author =       {Pierre Letouzey},
    title =        {{A New Extraction for Coq}},
    booktitle =    {{Types for Proofs and Programs, Second International Workshop, TYPES 2002, Berg en Dal, The Netherlands, April 24-28, 2002}},
    publisher =    {Springer-Verlag},
    series =       {Lecture Notes in Computer Science},
    volume =       2646,
    year =         2003,
    editor =       {Herman Geuvers and Freek Wiedijk},
    url =          {https://hal.science/hal-00150914/document}
}

@article{pwadler,
    author = {Wadler, Philip},
    title = {Propositions as Types},
    year = {2015},
    issue_date = {December 2015},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {58},
    number = {12},
    issn = {0001-0782},
    url = {https://doi.org/10.1145/2699407},
    doi = {10.1145/2699407},
    abstract = {Connecting mathematical logic and computation, it ensures that some aspects of programming are absolute.},
    journal = {Commun. ACM},
    month = {nov},
    pages = {75–84},
    numpages = {10}
}

@misc{compcert,
    title = "{CompCert} - {Main} page",
    author = "Xavier Leroy",
    year = "2022",
    month = "November",
    keywords = "CompCert, formal verification of compilers",
    url = "https://compcert.org",
    note = "Accessed: 2023-05-26"
}

@misc{deepspec,
    title = "The {Science} of {Deep} {Specification}",
    author = "The DeepSpec consortium",
    keywords = "DeepSpec, formal verification of software systems",
    url = "https://deepspec.org/main",
    note = "Accessed: 2023-05-26"
}

@article{secpriv,
    author = {Erbsen, Andres and Philipoom, Jade and Gross, Jason and Sloan, Robert and Chlipala, Adam},
    year = {2020},
    month = {08},
    pages = {23-30},
    title = {{Simple} {High-Level} {Code} {For} {Cryptographic} {Arithmetic}: {With} {Proofs}, {Without} {Compromises}},
    volume = {54},
    journal = {ACM SIGOPS Operating Systems Review},
    doi = {10.1145/3421473.3421477}
}

@incollection{typetheorystan,
	author       =	{Coquand, Thierry},
	title        =	{{Type Theory}},
	booktitle    =	{The {Stanford} Encyclopedia of Philosophy},
	editor       =	{Edward N. Zalta and Uri Nodelman},
	howpublished =	{\url{https://plato.stanford.edu/archives/fall2022/entries/type-theory/}},
	year         =	{2022},
	edition      =	{{F}all 2022},
	publisher    =	{Metaphysics Research Lab, Stanford University}
}

@incollection{lof1,
    title = {An {Intuitionistic} {Theory} of {Types}: {Predicative} {Part}},
    editor = {H.E. Rose and J.C. Shepherdson},
    series = {Studies in Logic and the Foundations of Mathematics},
    publisher = {Elsevier},
    volume = {80},
    pages = {73-118},
    year = {1975},
    booktitle = {Logic Colloquium '73},
    issn = {0049-237X},
    doi = {https://doi.org/10.1016/S0049-237X(08)71945-1},
    url = {https://www.sciencedirect.com/science/article/pii/S0049237X08719451},
    author = {Per Martin-Löf},
    abstract = {Publisher Summary
    The theory of types is intended to be a full-scale system for formalizing intuitionistic mathematics as developed. The language of the theory is richer than the languages of traditional intuitionistic systems in permitting proofs to appear as parts of propositions so that the propositions of the theory can express properties of proofs. There are axioms for universes that link the generation of objects and types and play somewhat the same role for the present theory as does the replacement axiom for Zermelo–Fraenkel set theory. The present theory is based on a strongly impredicative axiom that there is a type of all types in symbols. This axiom has to be abandoned, however, after it has been shown to lead to a contraction. This chapter discusses Normalization theorem, which can be strengthened in two ways: it can be made to cover open terms and it can be proved that every reduction sequence starting from an arbitrary term leads to a unique normal term after a finite number of steps. The definition of the notion of convertibility and the proof that an arbitrary term is convertible can no longer be separated because the type symbols and the terms are generated simultaneously.}
}

@incollection{lof2,
    title = {Constructive {Mathematics} and {Computer} {Programming}},
    editor = {L. Jonathan Cohen and Jerzy Łoś and Helmut Pfeiffer and Klaus-Peter Podewski},
    series = {Studies in Logic and the Foundations of Mathematics},
    publisher = {Elsevier},
    volume = {104},
    pages = {153-175},
    year = {1982},
    booktitle = {Logic, Methodology and Philosophy of Science VI},
    issn = {0049-237X},
    doi = {https://doi.org/10.1016/S0049-237X(09)70189-2},
    url = {https://www.sciencedirect.com/science/article/pii/S0049237X09701892},
    author = {Per Martin-Löf},
    abstract = {Publisher Summary
    This chapter discusses that relating constructive mathematics to computer programming seems to be beneficial. Among the benefits to be derived by constructive mathematics from its association with computer programming, one is that you see immediately why you cannot rely upon the law of excluded middle: its uninhibited use would lead to programs that one did not know how to execute. By choosing to program in a formal language for constructive mathematics, like the theory of types, one gets access to the conceptual apparatus of pure mathematics, neglecting those parts that depend critically on the law of excluded middle, whereas even the best high level programming languages so far designed are wholly inadequate as mathematical languages. The virtue of a machine code is that a program written in it can be directly read and executed by the machine. The distinction between low and high level programming languages is of course relative to the available hardware. It may well be possible to turn what is now regarded as a high level programming language into machine code by the invention of new hardware.}
}
