\chapter{Approach \& Design Choices}
\label{ch:approach_design_choices}

When translating an informal proof or specification to a formal proof,
one often has to decide how to model certain mathematical objects and their properties,
and which parts of a proof that can be simplified or left out entirely.
Our formalization effort has been focused mostly on \Cref{thm:3.2} and its proof.
We have left aside two concepts from \cite{mbezem}:

\begin{itemize}
    \item the relation between lattices and Horn clauses
    \item complexity theoretic claims about the problems
\end{itemize}

These are sections 2 and 4 from \cite{mbezem}, respectively.
We have also made some simplifications to various parts of our formalization,
which we will explain in more detail in the next subsection.

% For example, in Coq, there are several implementations of the mathematical notion of a \emph{set}.
% When choosing which implementation to use, there are often tradeoffs to consider.

\section{Simplifications for the sake of time}
\label{sec:simplifications}

\subsection{Incomplete formal proofs for some purely logical lemmas}
\label{ssec:incomplete_formal_proofs_for_some_purely_logical_lemmas}

We have chosen to not spend too much time fully completing the formal Coq proofs of some purely logical lemmas,
which are mainly used as intermediate steps in the proof of \Cref{thm:3.2}.
When we say "purely logical", we mean that they do not contribute anything to the
constructive part of the proof, and are not used in the extracted algorithm in any way
(we will expand on how most logical lemmas are removed by extraction in \Cref{ssec:ex_lfp_geq}).
They are purely logical in the sense that they only serve to prove the correctness of the proof.
As we will see later in this section, this is mainly due to
very complex or impossible-to-prove formal proofs of lemmas in our set implementation
being trivial when proving the same lemma informally.
The formal proofs of these lemmas are however not very interesting,
which is why we have not spent too much time on them.

\subsection{Leaving out the formal proof of \Cref{lem:3.3}}
\label{ssec:leaving_out_the_formal_proof_of_lem_33}

We have included a formulation of this lemma, but not a formal proof.
When testing the algorithm generated by our formalization of \Cref{thm:3.2},
we have manually edited the code to use the identity function instead of crashing due to
the lack of a proof of \Cref{lem:3.3}.
This simplification is sufficient for a surprising large number of problems, but not all;
the limitations of this simplification will be explained in more detail in \Cref{sec:limitations}.

\subsection{Proof of minimality}
\label{ssec:proof_of_minimality}

In our proof of \Cref{thm:3.2}, we have chosen to omit proving the minimality of the model generated by the algorithm.
Our algorithm does however generate a minimal model, but we have not proven
that it does.

To prove that the model generated by our algorithm is minimal,
we would have had to include the following proposition in our definition of \Cref{thm:3.2}:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:minimal_model}, caption={Proposition for minimal model}]
forall h : Frontier, sub_model Cs V V h -> geq h f.
\end{lstlisting}
\end{minipage}

We will explain the semantics of this proposition in more detail in \Cref{chap:implementation}.

\section{Modeling finite sets in Coq}
\label{sec:modeling_finite_sets_in_coq}

Sets in mathematics are seemingly simple structures; a set is a collection of elements.
A set cannot contain more than one of the same element (\emph{no duplicates}), and the elements are not arranged in any
specific order (\emph{no order}).
This is the naive definition of a set, not taking into account the complexity of this subtle notion,
different set theories, powerful axioms, and so on.

Sets are easy to work with when writing informal proofs.
We do not care about how our elements or sets are represented, we only care about their properties.
This does not hold for formal proofs though. In a formal proof, we need to specify exactly what happens
when you take the union of two sets, or how you determine whether or nor a set contains an element.

One of the most important data structures in functional computer programming is the \emph{list}.
Unlike a set, a list \emph{can} contain more than one of the same element, and the elements \emph{are} arranged in a
specific order.
The inductive definition of a list from Coq's standard library is as follows \cite{coqdatatypes}:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:list_def}, caption={Inductive definition of list type in Coq}]
Inductive list (A : Type) : list A :=
    | nil : list A
    | cons : A -> list A -> list A.
\end{lstlisting}
\end{minipage}

Using the \lstinline{cons} constructor, we can easily define any list containing any elements of the same type;
we can even have lists of lists.
The problem is of course that lists are not sets. We want to find a way to take into account the two important properties
of \emph{no duplicates} and \emph{no order} into our definition of lists.
In Coq, there are several ways to do this.

% https://stackoverflow.com/questions/36588263/how-to-define-set-in-coq-without-defining-set-as-a-list-of-elements

\subsection{List \& ListSet}
\label{ssec:list_listset}

As stated previously, Coq gives us a traditional definition of a list in the \textbf{List} module
\footnote{The definition of \lstinline{list} is actually located in the module \textbf{Init.Datatypes}, while everything else relating to lists is in the \textbf{List} module.} of the standard library \cite{coqlist}.
Due to the nature of its definition, it is very easy to construct proofs using induction or case distinction on lists;
we only need to check two cases.
This list implementation is type polymorphic, meaning any type can be used to construct a list of that type.
We do not need to give Coq any more information about the properties of the underlying type of the list other than the type itself.

The \textbf{List} module also gives us a tool to combat the possibility of duplicates in a list,
with \lstinline{NoDup} and \lstinline{nodup}.
\lstinline{NoDup} is an inductively defined proposition that asserts whether a list has duplicates or not.
\lstinline{nodup} is a function that takes in a list and returns a list with the same elements, but without duplicates.
In other words, a list for which \lstinline{NoDup} holds.
These two can be used to better represent finite sets as lists, since
we gain additional information about whether the list has duplicates or not.
Coq does not however inherently understand how to compare elements when checking a list for duplicates in \lstinline{nodup}.
Hence we have to provide a proof that the equality of the underlying type of the list is decidable.
An example of such a proof for the \lstinline{string} type would be:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:string_eq_dec}, caption={Decidability proof for string equality in Coq}]
Lemma string_eq_dec :
    forall x y : string, {x = y} + {x <> y}.
Proof.
    (* proof goes here *)
Qed.
\end{lstlisting}
\end{minipage}

Proofs as in \Cref{lst:string_eq_dec} are often given for the standard types in Coq such as \lstinline{nat},
\lstinline{bool} and \lstinline{string}.
As such, they can just be passed as arguments.
This convention of always passing the proof as an argument can be cumbersome and make the code hard to read,
but it is a necessary evil to get the properties we want.

Having just the implementation of the set structure is rarely enough; we also want to do operations on the set, and reason about these.
That is where the \textbf{ListSet} module comes in, which defines a new type called \lstinline{set} \cite{coqlistset}.
This type is just an alias for the \lstinline{list} type from the \textbf{List} module,
but the module also contains some useful functions.
Most of these functions treat the input as a set in the traditional sense,
meaning that they try to preserve the properties of \emph{no duplicates} and \emph{no order}.
Examples of some of these functions are \lstinline{set_add}, \lstinline{set_mem},
\lstinline{set_diff}, and \lstinline{set_union}.
We also get useful lemmas that prove common properties about these functions.
As with \lstinline{nodup}, these functions all require a proof of decidability of equality for the underlying type of the set.
One thing to note is that all these functions use \lstinline{bool} instead of
\lstinline{Prop}, and all require a decidability proof, which make the functions themselves decidable.

The module also gives us some lemmas to transform the boolean (type \lstinline{bool}) set-operation functions into
propositions (type \lstinline{Prop}), and vice versa. An example to illustrate this is the following lemma on \lstinline{set_mem}:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:set_mem_correct1}, caption={\lstinline{set_mem} lemma in \lstinline{ListSet} module}]
Lemma set_mem_correct1 {A : Type} (dec : forall x y : A, {x = y} + {x <> y}) :
    forall (x : A) (l : set A), set_mem dec x l = true -> set_In x l.
Proof.
    (* ... *)
Qed.
\end{lstlisting}
\end{minipage}

\lstinline{set_In} is just an alias for \lstinline{In} from the \textbf{List} module,
which is a proposition that is very common in many lemmas from the standard library.
Lemmas such as the example above are very useful when reasoning about boolean functions such as
\lstinline{set_mem} in proofs, as transforming them into propositions makes them easier to work with
and often enables us to use existing lemmas from the standard library.

Many of these boolean set functions, such as \lstinline{set_union},
take in two sets as arguments and pattern match on the structure of one of them.
For example, \lstinline{set_union} pattern matches on the second set given as an argument.
This makes proofs where we destruct or use induction on the second argument easy, such as this example:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:set_op_ex1}, caption={Easy proof of lemma in \lstinline{ListSet} module}]
Lemma set_union_l_nil {A : Type} (dec : forall x y : A, {x = y} + {x <> y}) :
    forall l : set A, set_union dec l [] = l.
Proof.
    destruct l; reflexivity.
Qed.
\end{lstlisting}
\end{minipage}

The downside is that even easy and seemingly trivial proofs that reason about the other argument are frustratingly hard
(or impossible) to prove, for example:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:set_op_ex2}, caption={Impossible proof of lemma in \lstinline{ListSet} module}]
Lemma set_union_nil_l {A : Type} (dec : forall x y : A, {x = y} + {x <> y}) :
    forall l : set A, set_union dec [] l = l.
Proof.
    (* ... *)
Qed.
\end{lstlisting}
\end{minipage}

What makes this proof impossible is that the order of elements in \lstinline{set_union dec [] l} is not the
same as in \lstinline{l} (due to how \lstinline{set_union} is implemented), and since equality on lists care about order,
we cannot prove this lemma.
However, there are ways to circumvent this problem.
Since we often reason about if an element is in a list, or if the list has a certain length,
we do not care about the order of the elements.
One example of such a "trick" is this definition of a strict subset relation on lists:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:subset_def}, caption={Strict subset relation on lists using \lstinline{incl}}]
Definition strict_subset {A : Type} (s1 s2 : set A) :=
  incl s1 s2 /\ ~(incl s2 s1).
\end{lstlisting}
\end{minipage}

\lstinline{incl} in this case is list inclusion, i.e. every element of \lstinline{s1} is also in \lstinline{s2}.
Instead of defining a strict subset as a list that is a subset of another list and where the lists are not equal,
we instead define it as a list that includes every element of another list and where some element of
the other list is not in the first list.
If we use these kinds of tricks and construct our proofs carefully, \textbf{ListSet} is a viable implementation for our purposes.
There might however be cases where the order of the elements in the lists come into play (e.g. such as in \Cref{lst:set_op_ex2}),
and that is where this implementation falls short.
Another thing to note is because of the polymorphic nature of the \lstinline{set} type, any additional lemmas proven about a set can be
used for any decidable type. This is useful if one needs sets with elements of different types,
which is the case in our implementation; we need sets of atoms, clauses, strings, etc.

\subsection{MSetWeakList}
\label{ssec:msetweaklist}

The Coq standard library also gives us another implementation of sets, \textbf{MSetWeakList} \cite{coqmsetweaklist}.
This implementation is a bit more complicated than the previous one,
but gives us more guarantees about the properties of the set.
The module is expressed as a functor, which in this case is a "function" that takes in a module as an argument, and again returns a module.
The module we give to the functor must satisfy some basic properties about the type we want to create a set of,
namely an equality relation, decidability of this relation and the fact that this relation is an equivalence relation.
The "output" from the functor is a new module containing functions and lemmas about set operations,
with our input type being the type of the elements of the set.
An example definition for a module of a set of atoms would be as follows:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:msetweaklist_ex1}, caption={Set of atoms in \lstinline{MSetWeakList} module}]
Module AtomEq : DecidableType.

  (* what is our base type? *)
  Definition t := Atom.

  Definition eq :=  (* ... *)

  Lemma eq_equiv :
    Equivalence eq.
  Proof.
    (* proof that eq is an equivalence relation *)
  Qed.

  Lemma eq_dec :
    forall x y : t, {eq x y} + {~ eq x y}.
  Proof.
    (* proof that eq is decidable *)
  Qed.

End AtomEq.

(* apply functor Make to module AtomEq *)
Module AtomSet := Make AtomEq.
\end{lstlisting}
\end{minipage}

The proofs of both lemmas above are trivial, but require a substantial amount of boilerplate code.
For every type we want to use as an element in a set, we have to go through this entire process.
In \textbf{List} and \textbf{ListSet}, we just had to pass in the proof of the decidability of equality of the type as an argument to the set functions and lemmas.
The structure of the sets in \textbf{MSetWeakList} is also a lot more complicated than the simple and intuitive definition of \textbf{List}.
This makes it harder to reason about the sets in proofs, given limited knowledge of Coq.

\subsection{Ensembles}
\label{ssec:ensembles}

Yet another implementation of sets is given by the \textbf{Ensembles} module
which defines the structure of a set as inductive propositions \cite{coqensembles}.
These inductive propositions assert some fact about if an element is in the set or not.
An example that illustrates this is the definition of \lstinline{Union}:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:union_ensemble}, caption={\lstinline{Union} in \textbf{Ensembles} module}]
Inductive Union (B C:Ensemble) : Ensemble :=
  | Union_introl : forall x:U, In B x -> In (Union B C) x
  | Union_intror : forall x:U, In C x -> In (Union B C) x.
\end{lstlisting}
\end{minipage}

We see that the first constructor of \lstinline{Union} asserts that if an element is in \lstinline{B},
then it is in the union of \lstinline{B} and \lstinline{C}.
\textbf{Ensembles} uses \lstinline{Prop} instead of \lstinline{bool},
making \textbf{Ensembles} useful for proofs where we do not care about decidability.
The biggest downside to this implementation is that we cannot reason about the size of the set.
We can only determine if an element is in the set, not how big the set is.
In our case, this makes the \textbf{Ensembles} module useless, since the theorem we are formalizing requires us to reason about the
size of the set.

\section{Choice of implementation of sets}
\label{sec:choice_of_implementation_of_sets}

The simplest set (or set-like) implementation in Coq are the \textbf{List} and \textbf{ListSet} modules.
These require minimal knowledge of advanced Coq syntax and behave like lists, making proofs by induction easy.
They are also polymorphic, meaning ease of use when making sets of different or self-defined types.
Because of these reasons, we chose to go with \textbf{List} and \textbf{ListSet}.
