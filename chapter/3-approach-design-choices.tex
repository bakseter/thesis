\chapter{Approach \& Design Choices}

When translating an informal proof to a formal proof or specification,
one often has to decide how to model certain mathematical objects
and/or properties. For example, in Coq, there are several implementations
of the mathematical notion of a \textit{set}. When choosing which implementation
to use, there are often tradeoffs to consider.

\section{Modeling Sets in Coq}

https://stackoverflow.com/questions/36588263/how-to-define-set-in-coq-without-defining-set-as-a-list-of-elements

\subsection{List \& ListSet}

As is common in most programming languages, Coq gives us a simple inductive definition of a list;
defined in the Coq standard library \textbf{List}.
A list can have duplicates, and the order of the elements are preserved. This is different from how we normally
define a set in mathematics, as a set in mathematics do not allow duplicates, and order is not preserved.
A list is defined as either an empty list, or an element prepended to another list.
Because of this definition, it is very easy to construct proofs using induction; we only need to check two cases.

The standard library also gives us a tool to combat the possibility of duplicates in a list,
with \mintinline{Coq}{NoDup} and \mintinline{Coq}{nodup}. \mintinline{Coq}{NoDup} is an inductively defined proposition that gives evidence (?) on whether a list
has duplicates or not. \mintinline{Coq}{nodup} is a function that takes in a list and returns a list without duplicates.

Having just the implementation of the set structure is rarely enough; we also want to do operations on the set, and reason about these.
That is were the library \textbf{ListSet} comes in. This definition of a set is just an alias for list, but its library gives us
some useful functions and lemmas. Most of these treat the input as a mathematical set, meaning that they try to preserve
the properties of \textit{no duplicates} and \textit{order}.
Examples of some of these functions are \mintinline{Coq}{set_add}, \mintinline{Coq}{set_mem}, \mintinline{Coq}{set_diff}, and \mintinline{Coq}{set_union}.
We also get useful lemmas that prove common properties about these functions.
One thing to note is that all these functions use \mintinline{Coq}{bool} when reasoning about if something is true or false.
This makes them decidable, but it also requires the equality of the underlying type of the set to be decidable.
A proof of the decidability of the underlying type must be supplied as an argument to the all the functions.
An example of the proof of the decidability of the equality for the \mintinline{Coq}{string} type would be:
\begin{minted}{Coq}
Lemma string_eq_dec : forall x y : string, {x = y} + {x <> y}.
Proof.
    (* proof goes here *)
Qed.
\end{minted}

These proofs are often given for the standard types in Coq such as \mintinline{Coq}{nat}, \mintinline{Coq}{bool} and \mintinline{Coq}{string}.
As such, they can just be passed to the functions as arguments.
This convention of always passing the proof as an argument can be cumbersome and make the code hard to read,
but it is a necessary evil to get the properties we want.

This still leaves the problem with order of elements in the list. This implementation gives us no concrete way to combat this,
but there are ways to circumvent the problem. Since we often reason about if an element is in a list, or if the list has
a certain length, we do not care about the order of the elements. If we construct our proofs with this in mind, \mintinline{Coq}{list} is a viable
implementation. There might however be cases where strict equality of two lists are needed, and that is where this implementation falls short.

\subsection{MSetWeakList}

\subsection{Ensembles}

\subsection{math-comp}


\section{Prop vs. Bool}
