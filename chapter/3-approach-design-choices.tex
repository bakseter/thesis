\chapter{Approach \& Design Choices}

% When translating an informal proof to a formal proof or specification,
% one often has to decide how to model certain mathematical objects and their properties.
% For example, in Coq, there are several implementations of the mathematical notion of a \textit{set}.
% When choosing which implementation to use, there are often tradeoffs to consider.

\section{Simplifications}

\subsection{Minimality}

\subsection{Lemma 3.3}

\section{Modeling Sets in Coq}

Sets in mathematics are seeminlgy simple structures.
A set is a collection of elements, where the elements are of a similiar type.
The set cannot contain more than one of the same element (\textit{no duplicates}), and the elements are not arranged in any
specific order (\textit{no order}). This is the most basic definition, ignoring more complex paradoxes and different set theories etc...

Sets are easy to work with when writing informal proofs.
We do not care about how our elements or sets are represented, we only care about their properties.
This does not hold for formal proofs though. In a formal proof, we need to specify exactly what happens
when you take the union of two sets, or how you determine if a set contains an element.

One of the most important data structures in functional computer programming is the \textit{list}.
Unlike a set, a list \textit{can} contain more than one of the same element, and the elements \textit{are} arranged in a
specific order.
The inductive definition of a list from Coq's standard library is as follows:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:list_def}, caption={Inductive def. of list type in Coq}]
Inductive list {A : Type} : list A :=
    | nil : list
    | cons : A -> list -> list.
\end{lstlisting}
\end{minipage}

Using the \lstinline{cons} constructor, we can easily define any list containing any elements of the same type;
we can even have lists of lists.
The problem is of course that lists are not sets. We want to find a way to include the two important properties
of \textit{no duplicates} and \textit{no order} into our definition of lists.
In Coq, there are several ways to do this.

% https://stackoverflow.com/questions/36588263/how-to-define-set-in-coq-without-defining-set-as-a-list-of-elements

\subsection{List \& ListSet}

As stated previously, Coq gives us a traditional definition of a list in the \textbf{List} module of the standard library.
Due to the nature of its definition, it is very easy to construct proofs using induction or case distinction on lists;
we only need to check two cases.
This list implementation is type polymorphic, meaning any type can be used to construct a list of that type.
We do not need to give Coq any more information about the properties of the underlying type of the list other than the type itself.

The \textbf{List} module also gives us a tool to combat the possibility of duplicates in a list,
with \lstinline{NoDup} and \lstinline{nodup}.
\lstinline{NoDup} is an inductively defined proposition that gives evidence \textcolor{red}{(is this correct?)}
of whether a list has duplicates or not.
\lstinline{nodup} is a function that takes in a list and returns a list without duplicates.
These two can be used effectively in proofs since we still keep the underlying list type,
but we also gain additional information about whether the list has duplicates or not.

Having just the implementation of the set structure is rarely enough; we also want to do operations on the set, and reason about these.
That is where the \textbf{ListSet} module comes in, which defines a new type called \lstinline{set}.
This type is just an alias for the \lstinline{list} type from the \textbf{List} module,
but the module also contains some useful functions.
Most of these functions treat the input as a set in the traditional sense,
meaning that they try to preserve the properties of \textit{no duplicates} and \textit{no order}.
Examples of some of these functions are \lstinline{set_add}, \lstinline{set_mem},
\lstinline{set_diff}, and \lstinline{set_union}.
We also get useful lemmas that prove common properties about these functions.
One thing to note is that all these functions use \lstinline{bool} instead of
\lstinline{Prop} when reasoning about if something is true or false.
This makes them decidable, but it also requires the equality of the underlying type of the set to be decidable.
A proof of this for the underlying type must be supplied as an argument to all the functions.
An example of such a proof for the \lstinline{string} type would be:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:string_eq_dec}, caption={Decidability proof for string equality in Coq}]
Lemma string_eq_dec :
    forall x y : string, {x = y} + {x <> y}.
Proof.
    (* proof goes here *)
Qed.
\end{lstlisting}
\end{minipage}

These proofs are often given for the standard types in Coq such as \lstinline{nat},
\lstinline{bool} and \lstinline{string}.
As such, they can just be passed to the functions as arguments.
This convention of always passing the proof as an argument can be cumbersome and make the code hard to read,
but it is a necessary evil to get the properties we want.

The module also gives us some lemmas to transform the boolean functions into propositions,
which is especially useful when reasoning about the functions in proofs.

Many of these set functions, such as \lstinline{set_union},
take in two sets as arguments and pattern match on the structure of one of them.
For example, \lstinline{set_union} pattern matches on the second set given as an argument.
This makes proofs where we destruct or use induction on the second argument easy, such as this example:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:set_op_ex1}, caption={Easy proof of lemma in \lstinline{ListSet}}]
(* example 1 *)
\end{lstlisting}
\end{minipage}

The downside is that even easy and seamingly trivial proofs that reason about the other argument are frustratingly hard,
for example:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:set_op_ex2}, caption={Hard proof of lemma in \lstinline{ListSet}}]
(* example 2 *)
\end{lstlisting}
\end{minipage}

The \textbf{ListSet} module gives us no concrete way to combat the order of elements in the set,
but there are ways to circumvent the problem.
Since we often reason about if an element is in a list, or if the list has a certain length,
we do not care about the order of the elements.
If we construct our proofs with this in mind, \textbf{ListSet} is a viable implementation.
There might however be cases where the order of the elements in the lists come into play (i.e. strict equality of two lists),
and that is where this implementation falls short.

Another thing to note is because of the polymorphic nature of the \lstinline{set} type, any additional lemmas proven about a set can be
used for any decidable type. This is useful if one needs sets with elements of different types.

\subsection{MSetWeakList}

The Coq standard library also gives us another implementation of sets, \textbf{MSetWeakList}.
This implementation is a bit more complicated than the previous one,
but gives us more guarantees about the properties of the set.
The module is expressed as a functor, which in this case is a "function" that takes in a module as an argument, and again returns a module.
The module we give to the functor must define some basic properties about the type we want to create a set of,
namely equality, decidability of equality and the equivalence relation of \textcolor{red}{(or on?)} equality.
The output from the functor is a module containing functions and lemmas about set operations,
with our input type being the type of the elements of the set.

This means that for every type we want to use as an element in the set, we have to go through this process.
In \textbf{List} and \textbf{ListSet}, we just had to pass in the proof of the equality of the type as an argument to the set functions and lemmas.
The structure of the sets in \textbf{MSetWeakList} is also a lot more complicated than the simple and intuitive definition of \textbf{List}.
This makes it harder to reason about the sets in proofs.

\subsection{Ensembles}

Another implementation of sets is given by the \textbf{Ensembles} module, which defines the structure of a set as inductive propositions.
This means it uses \lstinline{Prop} instead of \lstinline{bool},
making \textbf{Ensembles} useful for proofs where we do not care about decidability.
The biggest downside to this implementation, is that we cannot reason about the size of the set.
We can only determine if an element is in the set, not how big the set is.
In our case, this makes the \textbf{Ensembles} module useless, since the theorem we are formalizing requires us to reason about the
size of the set.

% \subsection{finset}

% If we venture past Coq's standard library and into the \textit{Mathematical Components} library, we find the \textbf{finset} module.

% \section{Prop vs. Bool}
