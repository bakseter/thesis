\chapter{Approach \& Design Choices}

When translating an informal proof or specification to a formal proof.
one often has to decide how to model certain mathematical objects and their properties.
For example, in Coq, there are several implementations of the mathematical notion of a \textit{set}.
When choosing which implementation to use, there are often tradeoffs to consider.
Examples of such trade-offs are simplicity of the implementation, ease of use, and performance.

\section{Simplifications}

We have made some simplifications to our formalization for the sake of time.

\subsection{Proof of minimality}

In our proof of Theorem 3.2, we have chosen to omit proving the minimality of the model generated by the algorithm.
Our algorithm does however generate a minimal model, but we have not proven
that it does.

To prove that the model generated by our algorithm is minimal,
we would have had to include the following proposition in our definition of Theorem 3.2:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:minimal_model}, caption={Proposition for minimal model}]
forall h : Frontier, sub_model Cs V V h -> geq h f.
\end{lstlisting}
\end{minipage}

\subsection{Omission of formal proof of Lemma 3.3}

We have included a formulation of this lemma, but not a proof.
When testing the algorithm generated by our formalization of Theorem 3.2,
we have manually edited the code to use the identity function instead of crashing due to
the lack of a proof of Lemma 3.3.
This simplification is sufficient for a surprising large number of problems;
the limitations of this simplification will be explained in more detail in \autoref{sec:limitations}.

\subsection{Incomplete proofs for some purely logical lemmas}

We have chosen to not waste too much time fully completing the proofs of some purely logical lemmas,
which are mainly used as intermediate steps in the proof of Theorem 3.2.
As we will se later in this section, this is mainly due to
very complex or impossible-to-prove lemmas in our set implementation
being trivial in informal mathematics.
The proofs of these lemmas are however not very interesting,
and they do not contribute to the correctnes of the implementation nor
the results of extracting code from the Coq formalization.

\section{Modeling finite sets in Coq}

Sets in mathematics are seeminlgy simple structures; a set is a collection of elements.
The set cannot contain more than one of the same element (\textit{no duplicates}), and the elements are not arranged in any
specific order (\textit{no order}).
This is the naive definition of a set, not taking into account the complexity of this subtle notion,
different set theories, powerful axioms, and so on.

Sets are easy to work with when writing informal proofs.
We do not care about how our elements or sets are represented, we only care about their properties.
This does not hold for formal proofs though. In a formal proof, we need to specify exactly what happens
when you take the union of two sets, or how you determine whether or nor a set contains an element.

One of the most important data structures in functional computer programming is the \textit{list}.
Unlike a set, a list \textit{can} contain more than one of the same element, and the elements \textit{are} arranged in a
specific order.
The inductive definition of a list from Coq's standard library is as follows:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:list_def}, caption={Inductive def. of list type in Coq}]
Inductive list {A : Type} : list A :=
    | nil : list
    | cons : A -> list -> list.
\end{lstlisting}
\end{minipage}

Using the \lstinline{cons} constructor, we can easily define any list containing any elements of the same type;
we can even have lists of lists.
The problem is of course that lists are not sets. We want to find a way to take into account the two important properties
of \textit{no duplicates} and \textit{no order} into our definition of lists.
In Coq, there are several ways to do this.

% https://stackoverflow.com/questions/36588263/how-to-define-set-in-coq-without-defining-set-as-a-list-of-elements

\subsection{List \& ListSet}

As stated previously, Coq gives us a traditional definition of a list in the \textbf{List} module of the standard library.
Due to the nature of its definition, it is very easy to construct proofs using induction or case distinction on lists;
we only need to check two cases.
This list implementation is type polymorphic, meaning any type can be used to construct a list of that type.
We do not need to give Coq any more information about the properties of the underlying type of the list other than the type itself.

The \textbf{List} module also gives us a tool to combat the possibility of duplicates in a list,
with \lstinline{NoDup} and \lstinline{nodup}.
\lstinline{NoDup} is an inductively defined proposition that asserts whether a list has duplicates or not.
\lstinline{nodup} is a function that takes in a list and returns a list with the same elements, but without duplicates.
In other words, a list for which \lstinline{NoDup} holds.
These two can be used to better represent finite sets as lists, since
we gain additional information about whether the list has duplicates or not.
Coq does not however inherently understand how to compare elements when checking a list for duplicates in \lstinline{nodup}.
Hence we have to provide a proof that the equality of the underlying type of the list is decidable.
An example of such a proof for the \lstinline{string} type would be:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:string_eq_dec}, caption={Decidability proof for string equality in Coq}]
Lemma string_eq_dec :
    forall x y : string, {x = y} + {x <> y}.
Proof.
    (* proof goes here *)
Qed.
\end{lstlisting}
\end{minipage}

Proofs as in \autoref{lst:string_eq_dec} are often given for the standard types in Coq such as \lstinline{nat},
\lstinline{bool} and \lstinline{string}.
As such, they can just be passed as arguments.
This convention of always passing the proof as an argument can be cumbersome and make the code hard to read,
but it is a necessary evil to get the properties we want.

Having just the implementation of the set structure is rarely enough; we also want to do operations on the set, and reason about these.
That is where the \textbf{ListSet} module comes in, which defines a new type called \lstinline{set}.
This type is just an alias for the \lstinline{list} type from the \textbf{List} module,
but the module also contains some useful functions.
Most of these functions treat the input as a set in the traditional sense,
meaning that they try to preserve the properties of \textit{no duplicates} and \textit{no order}.
Examples of some of these functions are \lstinline{set_add}, \lstinline{set_mem},
\lstinline{set_diff}, and \lstinline{set_union}.
We also get useful lemmas that prove common properties about these functions.
As with \lstinline{nodup}, these functions all require a proof of decidability of equality for the underlying type of the set.
One thing to note is that all these functions use \lstinline{bool} instead of
\lstinline{Prop}, and all require a decidability proof, which make the functions themselves decidable.

The module also gives us some lemmas to transform the boolean (type \lstinline{bool}) set-operation functions into
propositions (type \lstinline{Prop}), and vice versa. An example to illustrate this is the following lemma on \lstinline{set_mem}:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:set_mem_correct1}, caption={\lstinline{set_mem} lemma from \lstinline{ListSet}}]
Lemma set_mem_correct1 {A : Type} (dec : forall x y : A, {x = y} + {x <> y}) :
    forall (x : A) (l : set A), set_mem dec x l = true -> set_In x l.
\end{lstlisting}
\end{minipage}

\lstinline{set_In} is just an alias for \lstinline{In} from the \textbf{List} module,
which is a proposition that is very common in many lemmas from the standard library.
Lemmas such as the example above are very useful when reasoning about boolean functions such as
\lstinline{set_mem} in proofs, as transforming them into propositions makes them easier to work with
and often enables us to use existing lemmas from the standard library.

Many of these boolean set functions, such as \lstinline{set_union},
take in two sets as arguments and pattern match on the structure of one of them.
For example, \lstinline{set_union} pattern matches on the second set given as an argument.
This makes proofs where we destruct or use induction on the second argument easy, such as this example:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:set_op_ex1}, caption={Easy proof of lemma in \lstinline{ListSet}}]
Lemma set_union_l_nil {A : Type} (dec : forall x y : A, {x = y} + {x <> y}) :
    forall l : set A, set_union dec l [] = l.
Proof.
    destruct l; reflexivity.
Qed.
\end{lstlisting}
\end{minipage}

The downside is that even easy and seamingly trivial proofs that reason about the other argument are frustratingly hard
(or impossible) to prove, for example:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:set_op_ex2}, caption={Impossible proof of lemma in \lstinline{ListSet}}]
Lemma set_union_nil_l {A : Type} (dec : forall x y : A, {x = y} + {x <> y}) :
    forall l : set A, set_union dec [] l = l.
Proof.
    (* ... *)
Qed.
\end{lstlisting}
\end{minipage}

What makes this proof impossible is that the order of elements in \lstinline{set_union dec [] l} is not the
same as in \lstinline{l} (due to how \lstinline{set_union} is implemented), and since equality on lists care about order,
we cannot prove this lemma.
There are ways to circumvent this problem.
Since we often reason about if an element is in a list, or if the list has a certain length,
we do not care about the order of the elements.
If we construct our proofs with this in mind, \textbf{ListSet} is a viable implementation.
There might however be cases where the order of the elements in the lists come into play (i.e. such as in \autoref{lst:set_op_ex2}),
and that is where this implementation falls short.
Another thing to note is because of the polymorphic nature of the \lstinline{set} type, any additional lemmas proven about a set can be
used for any decidable type. This is useful if one needs sets with elements of different types.

\subsection{MSetWeakList}

The Coq standard library also gives us another implementation of sets, \textbf{MSetWeakList}.
This implementation is a bit more complicated than the previous one,
but gives us more guarantees about the properties of the set.
The module is expressed as a functor, which in this case is a "function" that takes in a module as an argument, and again returns a module.
The module we give to the functor must define some basic properties about the type we want to create a set of,
namely an equality relation, decidability of this relation and the fact that this relation is an equivalence relation.
The output from the functor is a module containing functions and lemmas about set operations,
with our input type being the type of the elements of the set.

This means that for every type we want to use as an element in the set, we have to go through this process.
In \textbf{List} and \textbf{ListSet}, we just had to pass in the proof of the equality of the type as an argument to the set functions and lemmas.
The structure of the sets in \textbf{MSetWeakList} is also a lot more complicated than the simple and intuitive definition of \textbf{List}.
This makes it harder to reason about the sets in proofs.

\subsection{Ensembles}

Yet another implementation of sets is given by the \textbf{Ensembles} module, which defines the structure of a set as inductive propositions.
This means it uses \lstinline{Prop} instead of \lstinline{bool},
making \textbf{Ensembles} useful for proofs where we do not care about decidability.
The biggest downside to this implementation, is that we cannot reason about the size of the set.
We can only determine if an element is in the set, not how big the set is.
In our case, this makes the \textbf{Ensembles} module useless, since the theorem we are formalizing requires us to reason about the
size of the set.

\section{Choice of implementation of sets}

The simplest set (or set-like) implementation in Coq are the \textbf{List} and \textbf{ListSet} modules.
These require minimal knowledge of advanced Coq syntax and behave like lists, making proofs by induction easy.
They are also polymorphic, meaning ease of use when making sets of different or self-defined types.
Because of these reasons, we chose to go with \textbf{List} and \textbf{ListSet}.
