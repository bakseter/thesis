\chapter{Approach \& Design Choices}

When translating an informal proof to a formal proof or specification,
one often has to decide how to model certain mathematical objects
and/or properties. For example, in Coq, there are several implementations
of the mathematical notion of a \textit{set}. When choosing which implementation
to use, there are often tradeoffs to consider.

\section{Modeling Sets in Coq}

https://stackoverflow.com/questions/36588263/how-to-define-set-in-coq-without-defining-set-as-a-list-of-elements

\subsection{List \& ListSet}

As is common in most programming languages, Coq gives us a simple inductive definition of a list;
defined in the Coq standard library in the \textbf{List} module.
A list can have duplicates, and the order of the elements are preserved. This is different from how we normally
define a set in mathematics, as a set in mathematics do not allow duplicates, and order is not preserved.
A list is defined as either an empty list, or an element prepended to another list.
Because of this definition, it is very easy to construct proofs using induction; we only need to check two cases.

\newpage

The \textbf{List} module also gives us a tool to combat the possibility of duplicates in a list,
with \mintinline{Coq}{NoDup} and \mintinline{Coq}{nodup}. \mintinline{Coq}{NoDup} is an inductively defined proposition that gives evidence (?)
on whether a list has duplicates or not. \mintinline{Coq}{nodup} is a function that takes in a list and returns a list without duplicates.

Having just the implementation of the set structure is rarely enough; we also want to do operations on the set, and reason about these.
That is were the \textbf{ListSet} module comes in.
The implementation of a set in this module is just an alias for list from the \textbf{List} module,
but the module also contains some useful functions. Most of these treat the input as a mathematical set,
meaning that they try to preserve the properties of \textit{no duplicates} and \textit{order}.
Examples of some of these functions are \mintinline{Coq}{set_add}, \mintinline{Coq}{set_mem}, \mintinline{Coq}{set_diff},
and \mintinline{Coq}{set_union}.
We also get useful lemmas that prove common properties about these functions.
One thing to note is that all these functions use \mintinline{Coq}{bool} when reasoning about if something is true or false.
This makes them decidable, but it also requires the equality of the underlying type of the set to be decidable.
A proof of the decidability of the underlying type must be supplied as an argument to all the functions.
See listing \ref{lst:string_eq_dec} for an example of such a proof.

These proofs are often given for the standard types in Coq such as \mintinline{Coq}{nat}, \mintinline{Coq}{bool} and \mintinline{Coq}{string}.
As such, they can just be passed to the functions as arguments.
This convention of always passing the proof as an argument can be cumbersome and make the code hard to read,
but it is a necessary evil to get the properties we want.

Many of these set functions, such as \mintinline{Coq}{set_union}, take in two sets as arguments and pattern match on the structure of one of them.
\mintinline{Coq}{set_union} pattern matches on the second set given as an argument.
This makes proofs where we destruct or use induction on the second argument easy, see listing \ref{lst:set_union_nodup_r}.
The downside is that even easy and seamingly trivial proofs that reason about the other argument are frustratingly hard,
see lisitng \ref{lst:set_union_nodup_l}.

This still leaves the problem with order of elements in the list. This implementation gives us no concrete way to combat this,
but there are ways to circumvent the problem. Since we often reason about if an element is in a list, or if the list has
a certain length, we do not care about the order of the elements. If we construct our proofs with this in mind, \mintinline{Coq}{list} is a viable
implementation. There might however be cases where strict equality of two lists are needed, and that is where this implementation falls short.

\subsection{MSetWeakList}

The Coq standard library also gives us another implementation of sets, \textbf{MSetWeakList}.
This implementation is a bit more complicated than the previous one, but gives us more guarantees in regards to the set having no duplicates
and order not being preserved. The module is expressed as a functor.
The functor, in this case, is a function that takes in a module as an argument, and again returns a module.
The module we give to the functor must define some basic properites about the type we want to create a set of, namely equality,
decidability of equality and the equivalence of equality.
The output from the functor is a module containing functions and lemmas about set operations, with our input type being the type of the elements of the set.

This means that for every type we want to use as an element in the set, we have to go through this process.
In \textbf{List} and \textbf{ListSet}, we just had to pass in the proof of the equality of the type as an argument to the functions.
The structure of the sets in \textbf{MSetWeakList} is also a lot more complicated than the simple and intuitive definition of \textbf{List}.
This makes it harder to reason about the sets in proofs.


\subsection{Ensembles}

\subsection{math-comp}


\section{Prop vs. Bool}
