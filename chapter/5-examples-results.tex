\chapter{Examples \& Results}

\section{Examples using the extracted Haskell code}

\subsection{Defining examples for extraction in Coq}

When extracting \lstinline{thm_32} to Haskell, Coq
creates a Haskell function that takes as input every variable
that is used in the definition of \lstinline{thm_32}.
This is what the type signature of such a function looks like in Haskell:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Haskell, label={lst:thm_32_type_sig_haskell}, caption={Type signature of Haskell extraction of \lstinline{thm_32}}]
thm_32 :: Prelude.Integer -> Prelude.Integer -> (Set Clause0) ->
          (Set Prelude.String) -> (Set Prelude.String) -> Frontier ->
          Ex_lfp_geq -> Ex_lfp_geq
thm_32 n m cs v w f x =
    {- ... -}
\end{lstlisting}
\end{minipage}

This all looks familiar: \lstinline{n, m} are two natural numbers which are used for induction in the proof of the theorem,
\lstinline{cs} is the set of clauses, \lstinline{v, w} are the set of variables
and \lstinline{f} is the frontier.
We also see an additional argument of type \lstinline[language=Haskell]{Ex_lfp_geq}, and that the return type
of the function also has this type.
In the extraction, \lstinline[language=Haskell]{Ex_lfp_geq} has the following definition:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Haskell, label={lst:ex_lfp_geq_haskell}, caption={\lstinline{Ex_lfp_geq} in Haskell}]
type Ex_lfp_geq_S = Frontier
type Ex_lfp_geq = Ex_lfp_geq_S
\end{lstlisting}
\end{minipage}

Looking back at the Coq definition of \lstinline{ex_lfp_geq} (see \autoref{lst:ex_lfp_geq_def}),
it defined a proposition that stated that there
exists a \lstinline{g : Frontier}, such that the proposition holds.
If such a \lstinline{g} exists, then the \lstinline{g} itsself is evidence (proof) that the proposition holds.
Thus, the type of the proof of \lstinline{ex_lfp_geq} is just the type of \lstinline{Frontier}.

\textcolor{red}{The rest of the section includes a lot of guesswork, I'm trying to understand the types in Coq and how they relate to Set, Prop, and extracted stuff in Haskell}

First, we can look at the type signature of \lstinline{thm_32} to see what arguments we need to give it.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:thm_32_type_sig_coq}, caption={Type signature of \lstinline{thm_32} in Coq}]
thm_32
     : forall (n m : nat) (Cs : set Clause) (V W : set string) (f : Frontier),
       pre_thm n m Cs V W f
\end{lstlisting}
\end{minipage}

We see that the type of \lstinline{thm_32} is a proof of \lstinline{pre_thm}, with the quantified variables
\lstinline{n, m, Cs, V, W, f}.
These are the same variables that we saw in the type signature of the Haskell extraction of \lstinline{thm_32}.
We can now look at the type signature of \lstinline{pre_thm}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:pre_thm_type_sig_coq}, caption={Type signature of \lstinline{pre_thm} in Coq}]
pre_thm
     : nat ->
       nat -> set Clause -> set string -> set string -> Frontier -> Set
\end{lstlisting}
\end{minipage}

Given all quantified variables from \lstinline{thm_32}, we see that the type of \lstinline{pre_thm} is
an object in \lstinline{Set}. This object is \lstinline{ex_lfp_geq}.
\textcolor{something about depedenent types? since the type of ex_lfp_geq depends on the values of the quantified variables?}

In summary, the type of \lstinline{thm_32} is a proof of \lstinline{pre_thm}, which,
when given the quantified variables \lstinline{n, m, Cs, V, W, f}, returns a proof of \lstinline{ex_lfp_geq}
for these same variables.
As we saw earlier in this section, a proof of \lstinline{ex_lfp_geq}
is simply a \lstinline{Frontier} that satisfies the conditions in \lstinline{ex_lfp_geq}.
Since these conditions are logical objects they are ignored when extacting to Haskell,
and we are left with just the frontier.

With all this information, we can now start to define a computable and extractable example for \lstinline{thm_32}.
It is easiest to define as much of the example as possible in Coq and then extract it to Haskell,
since Coq heavily prioritizes code correctness over readability when extracting,
making much of the Haskell code hard to read due to unconventional syntax.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:thm_32_coq_example}, caption={\lstinline{thm_32} example}]
Example Cs := [
  ["a" & 0] ~> "b" & 1;
  ["b" & 1] ~> "c" & 2
].
Example f := frontier_fin_0.
Example vars' := nodup string_dec (vars Cs).

Example thm_32_example :=
  thm_32
    (Datatypes.length vars')
    (Datatypes.length vars')
    Cs
    vars'
    []
    f.
\end{lstlisting}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{lstinline}[language=Coq, label={lst:thm_32_type_sig_coq}, caption={Type signature of \lstinline{thm_32} in Coq}]

\end{lstlisting}
\end{minipage}

If we would like to execute \lstinline{thm_32} entirely in Coq, we would need to give a proof of each of these assumptions.
These proofs are trivial but ultimately useless (and tedious to write down),
so we only give the arguments that are strictly necessary for the extraction.
Once these assumptions are ignored, we see that the final argument to \lstinline{thm_32} is of the type
\lstinline{


Since Coq elimiates many of the logical parts of the proof when extracting,
\cite[p. ~8]{coqextroverview},
we can avoid the tedious task of proving all the assumptions of \lstinline{pre_thm} by simply
using the extracted Haskell function for \lstinline{thm_32_example}, which as we saw previously only needs a \lstinline{Frontier}
as input (since we have given every other argument necessary), and returns a \lstinline{Frontier} as output.
This frontier should be the same as the one given as input, i.e. \lstinline{f} in this example.
We can then apply the extracted Haskell function \lstinline{thm_32_example} to \lstinline{f},
and we receive a \lstinline{Frontier} as output.
This \lstinline{Frontier} can then be applied to any string to get the resulting value of the string,
which should be either a natural number or infinity.

\subsection{Necessary alterations to the extracted Haskell code}

Since we have not given a proof of lemma 3.3, Coq will include a definition of the lemma in the extracted code,
but will immidiately crash the program if the extracted function representing the lemma is ever called.
We circumvent this by replacing the extracted definition of \lstinline{lem_33} with the identity function
for any frontier. We will look at some examples where this workaround is not sufficient in
\autoref{sec:limitations}.

If we want to actually read the output from the extracted functions, we also need to
derive a \lstinline{Show} instance for \lstinline{Ninfty}.
What this means is that we need to define a function \lstinline{show :: Ninfty -> String},
which will be used by Haskell to convert a \lstinline{Ninfty} to a \lstinline{String}.
This can be done by simply adding the line \lstinline{deriving Prelude.Show} to the definition of \lstinline{Ninfty},
which will make Haskell just print the constructors of \lstinline{Ninfty},
which will be either \lstinline{Fin n} for some natural number \lstinline{n},
or \lstinline{Infty} for infinity.

\subsection{Example output}

We can now run the example from \autoref{lst:thm_32_coq_example} using GHCi,
which is an interactive Haskell interpreter that comes with the Haskell compiler GHC.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Haskell, label={lst:thm_32_haskell_output}, caption={\lstinline{thm_32} example output}]
ghci> (thm_32_example f) "a"
Fin 0
ghci> (thm_32_example f) "b"
Fin 1
ghci> (thm_32_example f) "c"
Fin 2
ghci> (thm_32_example f) "x"
Fin 0
\end{lstlisting}
\end{minipage}

When given a string value (variable) from the set of clauses, the function will compute the value of that variable.
When given any other variable, the function will return the value that the original frontier given as input
would return for that variable, which is always \lstinline{Fin 0} in this case
(since in our example the frontier is \lstinline{frontier_fin_0},
which is a constant function that always returns \lstinline{Fin 0}).

\section{Real world example}

As stated previously, the algorithm described Theorem 3.2 is being
tested for use in checking loops and determining universe levels in the
type system of Coq.

\textcolor{red}{explain more about type universes in Coq, see LateX comment for possible citation}
% http://adam.chlipala.net/cpdt/html/Universes.html

\section{Limitations}
\label{sec:limitations}
