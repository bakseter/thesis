\chapter{Examples \& Results}
\label{chap:examples_results}

\section{Examples using the extracted Haskell code}
\label{sec:examples}

\subsection{Defining examples for extraction in Coq}
\label{sec:defining_examples}

It is easiest to define as much of the example as possible in Coq and then extract it to Haskell,
since Coq heavily prioritizes code correctness over readability when extracting.
making much of the Haskell code hard to read due to unconventional syntax,
e.g. using a recursion operator insted of calling a function recursively.
First, we can look at the type signature of \lstinline{thm_32} to see what arguments we need to give it.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:thm_32_type_sig_coq}, caption={Type signature of \lstinline{thm_32} in Coq}]
thm_32
     : forall (n m : nat) (Cs : set Clause) (V W : set string) (f : Frontier),
       pre_thm n m Cs V W f
\end{lstlisting}
\end{minipage}

We see that the type of \lstinline{thm_32} is a proof of \lstinline{pre_thm}, with the quantified variables
\lstinline{n, m, Cs, V, W, f}.
We can now look at the type signature of \lstinline{pre_thm}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:pre_thm_type_sig_coq}, caption={Type signature of \lstinline{pre_thm} in Coq}]
pre_thm
     : nat ->
       nat -> set Clause -> set string -> set string -> Frontier -> Set
\end{lstlisting}
\end{minipage}

We see that \lstinline{pre_thm} returns an object in \lstinline{Set}.
This object is the proposition defined in \autoref{lst:pre_thm_def},
where all the variables are the arguments given to \lstinline{pre_thm}.
This proposition states some logical assumptions, and concludes with a definition of \lstinline{ex_lfp_geq}.
By the notion of propositions as types, \lstinline{ex_lfp_geq} is a function
that transforms a proof of the assumptions into a proof of the conclusion.
Since the conlusion is a definition of \lstinline{ex_lfp_geq} instantiated with some variables,
we get a proof of \lstinline{ex_lfp_geq} for these same variables.
Looking at the definition of \lstinline{ex_lfp_geq},
it defines a proposition stating that there exists a \lstinline{g : Frontier} such that the proposition holds.
If such a \lstinline{g} exists, then the \lstinline{g} itsself is evidence (proof) that the proposition holds.
Hence, a proof of \lstinline{ex_lfp_geq} is simply a \lstinline{Frontier} that satisfies the conditions in \lstinline{ex_lfp_geq}.
Since these conditions are logical objects, they are ignored when extacting to Haskell,
and we are left with just the frontier.

With all this information, we can now define an example of \lstinline{thm_32} in Coq.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:thm_32_coq_example}, caption={\lstinline{thm_32} example}]
Example Cs := [
  ["a" & 0] ~> "b" & 1;
  ["b" & 1] ~> "c" & 2
].
Example f := frontier_fin_0.
Example vars' := nodup string_dec (vars Cs).

Example thm_32_example :=
  thm_32
    (Datatypes.length vars')
    (Datatypes.length vars')
    Cs
    vars'
    []
    f.
\end{lstlisting}
\end{minipage}

Since Coq elimiates many of the logical parts of the proof when extracting,
\cite[p. ~8]{coqextroverview},
we can avoid the tedious task of proving all the assumptions of \lstinline{pre_thm} by simply
using the extracted Haskell function for \lstinline{thm_32_example}.
The final assumption of \lstinline{pre_thm}, namely \lstinline{ex_lfp_geq Cs (nodup string_dec W) (nodup string_dec W) f},
will however not be removed by Coq, since it is an object in \lstinline{Set}.
This assumption is trivially true for any \lstinline{f}, since \lstinline{W} is an empty list.
Since Coq simplifies the type of \lstinline{ex_lfp_geq} to \lstinline{Frontier},
we can just include the same frontier \lstinline{f} as in \lstinline{thm_32_example} to the extracted Haskell
version of \lstinline{thm_32_example}.

We then receive a \lstinline{Frontier} as output, which is the result of the theorem;
the frontier that is a model of a set of clauses \lstinline{Cs}.
This frontier can then be applied to any string representing a variable to get the value of that variable in the model,
which should be either a natural number or infinity.

\subsection{Necessary alterations to the extracted Haskell code}
\label{sec:necessary_alterations}

Since we have not given a proof of Lemma 3.3, Coq will include a definition of the lemma in the extracted code,
but will immidiately crash the program if the extracted function representing the lemma is ever called.
We circumvent this by replacing the extracted definition of \lstinline{lem_33} with the identity function
for any frontier. We will look at some examples where this workaround is not sufficient in
\autoref{sec:limitations}.

If we want to actually read the output from the extracted functions, we also need to
derive a \lstinline{Show} instance for \lstinline{Ninfty}.
What this means is that we need to define a function \lstinline{show :: Ninfty -> String},
which will be used by Haskell to convert a \lstinline{Ninfty} to a \lstinline{String}.
This can be done by simply adding the line \lstinline{deriving Prelude.Show} to the definition of \lstinline{Ninfty},
which will make Haskell just print the constructors of \lstinline{Ninfty},
which will be either \lstinline{Fin n} for some natural number \lstinline{n},
or \lstinline{Infty} for infinity.

\subsection{Example output}
\label{sssec:example_output}

We can now run the example from \autoref{lst:thm_32_coq_example} using GHCi,
which is an interactive Haskell interpreter that is included with GHC, the standard Haskell compiler.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Haskell, label={lst:thm_32_haskell_output}, caption={\lstinline{thm_32} example output}]
ghci> (thm_32_example f) "a"
Fin 0
ghci> (thm_32_example f) "b"
Fin 1
ghci> (thm_32_example f) "c"
Fin 2
ghci> (thm_32_example f) "x"
Fin 0
\end{lstlisting}
\end{minipage}

When given a string value (variable) from the set of clauses, the function will compute the value of that variable.
When given any other variable, the function will return the value that the original frontier given as input
would return for that variable, which is always \lstinline{Fin 0} in this case
(since in our example the frontier is \lstinline{frontier_fin_0},
which is a constant function that always returns \lstinline{Fin 0}).

\section{Real world example}
\label{sec:real_world_example}

As stated previously, the algorithm described Theorem 3.2 is being
tested for use in checking loops and determining universe levels in the
type system of Coq.

\textcolor{red}{explain more about type universes in Coq, see URL for possible citation}
\url{http://adam.chlipala.net/cpdt/html/Universes.html}

\section{Limitations}
\label{sec:limitations}
