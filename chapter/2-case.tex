\chapter{The Case in Question}

\section{Overview}

We have used the Coq proof assistant to formalize parts of the proofs of the following paper, \citeauthor{mbezem} \cite{mbezem}.
This paper solves two problems that occur in dependent type systems where typings depend
on universe-level constraints. We focused on formalizing the proof of Theorem 3.2 from the paper.
Since this proof is complex enough that mistakes are possible, it was a good candidate for formalization.
It also has direct applications to the formalization and verification of the Coq proof assistant itself,
since the algorithm outlined in the proof is being tested
for use in checking loops in Coq's type system. \cite{coqgithub}

\section{Relevant parts of the paper}

In the paper, join-semilattices with inflationary endomorphisms
are simply called semilattices. An inflationary endomorphism is a function
that maps an element to itself or to a greater element in the ordered set.
A join-semilattice is a partially ordered set in which any two elements have a least upper bound,
called their join.

A semilattice presentation consists of a set $V$ of generators
(also called variables) and a set $C$ of constraints
(also called relations).

A term over V has the form $x_1 + k_1 \lor \ldots \lor x_m + k_m$, where $x_i \in V$ and $k_i \in \mathbb{N}$.

A relation is an equation $s = t$, where $s$ and $t$ are terms over $V$.
A constraint, like $x = y^+$ (with $x, y \in V$), expresses a relation between the generators (variables) $x$ and $y$.

Horn clauses are propositional clauses $A \rightarrow b$, with a non-empty body $A$ and conclusion $b$.
The atoms are of the form $x + k$, where $x \in V, k \in \mathbb{N}$.
We call this special form of Horn clauses simply \textit{clauses}.

For each constraint $s = t$, we generate $m + n$ clauses by replacing join by conjunction and implication.
We define $S_{s=t}$ as the set of these clauses and $S_C$ as the union of all $S_{s=t}$, with $s = t$ as a constraint in C.

Predecessor clauses are derived from the axiom $x \; \lor \; x^{+} = x^{+}$ and have the form
$x + k + 1 \rightarrow x + k$, where $(x \in V, k \in \mathbb{N})$

We define closure under shifting upwards as follows:
$A \rightarrow b$ is in the set of clauses, then so must $A + 1 \rightarrow b + 1$ be.
$A + 1$ denotes the set of atoms of the form $a + 1$, where $a \in A$.

Given a finite semilattice presentation $(V, C)$,
and a subset $W \subseteq V$, we denote by
$\overline{S_C}$ the smallest set of clauses that is closed under shifting upwards,
by $\overline{S_C} \mid W$ the set of clauses in $\overline{S_C}$
mentioning only variables in $W$, and by $\overline{S_C} \downarrow W$
the set of clauses in $\overline{S_C}$ with conclusion over $W$.

A function $f : V \rightarrow N^{\infty}$ is a model $\ldots$


\subsection{Lemma 3.1}

Lemma 3.1 states that given $f : V \rightarrow N^{\infty}$,
and a clause $A \rightarrow b$, let $P$ be the problem whether or not
$A + k \rightarrow b + k$ is satisfied by $f$ for all $k \in N$.
Then $P$ is decidable. \cite[p.~3]{mbezem}

The proof of lemma 3.1 demonstrates that the problem $P$
is decidable, meaning we can indeed write an algorithm that
determines whether or not the problem holds for all $k \in N$.
Lemma 3.1 is also crucial for making case distinctions
in further proofs, since we know that any $S_C$ is finite.

\subsection{Theorem 3.2}

Theorem 3.2 states that for any finite semilattice representation
$(V, C)$ and any function $f : V \rightarrow N^{\infty}$,
the least $g \ge f$ that is a model of $\overline{S_C}$ can be computed.
\cite[p.~3]{mbezem}

\subsection{Lemma 3.3}

Theorem 3.2 has a special case that is solved by an additional lemma,
lemma 3.3. This lemma states that given a finite semilattive presentation
$(V, C)$ and a strict subset $W \subset V$, if for any function
$f : W \rightarrow N^{\infty}$, the least $g \ge f$ that is a model of
$\overline{S_C}|W$ can be computed, then for any function
$f : V \rightarrow N^{\infty}$ with $f(V - W) \subseteq N$,
the least $h \ge f$ that is a model of $\overline{S_C}\downarrow W$ can be computed.
\cite[p.~3-4]{mbezem}
