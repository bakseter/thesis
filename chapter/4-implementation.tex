\chapter{Implementation of Logical Notions}

\section{Data types}

The paper \cite{mbezem} uses heavily Horn clauses, which it (and we) simply call clauses.
Following the definition of a Horn clause, a clause contains a body of a set of atomic formulas,
or atoms, and a single atom as the head \cite{halbert}.

We also define the atoms in the clauses as containing one string and one natural number,
since this is sufficient for our implementation.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:atom_clause_def}, caption={\lstinline{Atom} and \lstinline{Clause} in Coq}]
Inductive Atom : Type :=
  | atom : string -> nat -> Atom.

Notation "x & k" := (atom x k) (at level 80).

Inductive Clause : Type :=
  | clause : set Atom -> Atom -> Clause.

Notation "ps ~> c" := (clause ps c) (at level 81).
\end{lstlisting}
\end{minipage}

Note also the \lstinline{Notation}-syntax, which allow us to define a custom notation,
making the code easier to read. The expression on the left-hand side of the \lstinline{:=} in quotation marks
is equivalent to the expression on the right-hand side in parentheses.
The level determines which notation should take precedence, with a higher level equaling a higher precedence.

As we saw when discussing \cite{mbezem} in \autoref{sec:case},
we also want to model functions of the form $f : V \rightarrow N^{\infty}$.
We implement this in Coq using two types, \lstinline{Ninfty} and \lstinline{Frontier}.
\lstinline{Ninfty} is either a natural number or infinity.
\lstinline{Frontier} is a function from a string (variable) to \lstinline{Ninfty}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:ninfty_frontier_def}, caption={\lstinline{Ninfty} and \lstinline{Frontier} in Coq}]
Inductive Ninfty : Type :=
  | infty : Ninfty
  | fin   : nat -> Ninfty.

Definition Frontier := string -> Ninfty.
\end{lstlisting}
\end{minipage}

Using these definitions of \lstinline{Atom}, \lstinline{Clause} and \lstinline{Frontier},
we can define functions that check whether any given atom or clause is satisfied for any frontier.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:atom_clause_true_def}, caption={\lstinline{atom_true} and \lstinline{clause_true} in Coq}]
Definition atom_true (a : Atom) (f : Frontier) : bool :=
  match a with
  | (x & k) =>
    match f x with
    | infty => true
    (* se explantation for <=? below *)
    | fin n => k <=? n
    end
  end.

Definition clause_true (c : Clause) (f : Frontier) : bool :=
  match c with
  | (conds ~> conc) =>
    if fold_right andb true (map (fun a => atom_true a f) conds)
    then (atom_true conc f)
    else true
  end.
\end{lstlisting}
\end{minipage}

The infix function \lstinline{<=?} is the boolean (and hence decidable) version of the
Coq function \lstinline{<=}, which uses \lstinline{Prop} and is not inherently decidable without
additional lemmas.

We can also define functions that "shift" the number value of atoms or whole clauses by some amount \lstinline{n : nat}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:shift_atom_clause_true}, caption={\lstinline{shift_atom} and \lstinline{shift_clause} in Coq}]
Definition shift_atom (n : nat) (a : Atom)  : Atom :=
  match a with
  | (x & k) => (x & (n + k))
end.

Definition shift_clause (n : nat) (c : Clause) : Clause :=
  match c with
  | conds ~> conc =>
    (map (shift_atom n) conds) ~> (shift_atom n conc)
  end.
\end{lstlisting}
\end{minipage}

Using these definitions, we can now define an important property that will be used
later; whether a set of clauses is true for any shift of \lstinline{n : nat}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:all_shifts_true}, caption={\lstinline{all_shifts_true} in Coq}]
Definition all_shifts_true (c : Clause) (f : Frontier) : bool :=
  match c with
  | (conds ~> conc) =>
      match conc with
      | (x & k) =>
          match f x with
          | infty => true
          | fin n => clause_true (shift_clause (n + 1 - k) c) f
          end
      end
  end.
\end{lstlisting}
\end{minipage}

\section{Semantic functions and predicates}

\subsection{The function \lstinline{sub_model}}

Given any set of clauses and a function assigning values to the variables,
we can determine if this gives us a valid model, that is,
whether all shifts of all clauses are satisfied.

We translate this property to Coq as the recursive function \lstinline{sub_model}.
We have two additional arguments \lstinline{V} and \lstinline{W}; these are
the set of variables (strings) from the set of clauses, and all changed variables \textcolor{red}{(expand on this)}, respectively.
The function \lstinline{vars_set_atom} simply returns all the variables used
in a set of atoms as a set of strings.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:sub_model_def}, caption={The function \lstinline{sub_model} in Coq}]
Fixpoint sub_model (Cs : set Clause) (V W : set string) (f : Frontier) : bool :=
  match Cs with
  | []      => true
  | (l ~> (x & k)) :: t  =>
    (* conclusion not in W *)
    (negb (set_mem string_dec x W) ||
    (* some premise not in V *)
     negb (
       fold_right andb true
         (map (fun x => set_mem string_dec x V) (vars_set_atom l))
     ) ||
     all_shifts_true (l ~> (x & k)) f
    ) && sub_model t V W f
  end.
\end{lstlisting}
\end{minipage}

\subsection{The function \lstinline{geq}}

We want to determine whether all the values assigned to a set of variables
from one frontier are greater than or equal to all the values assigned to a set of variables
from another frontier. The values are of the type \lstinline{Ninfty}, and the function
only returns true if \textbf{all} the values from the first frontier are greater than
the values from the second frontier.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:geq_def}, caption={Pointwise comparing frontiers with \lstinline{geq} in Coq}]
Fixpoint geq (V : set string) (g f : Frontier) : bool :=
  match V with
  | []      => true
  | h :: t  =>
    match g h with
    | infty => geq t g f
    | fin n =>
        match f h with
        | infty => false
        | fin k => (k <=? n) && geq t g f
        end
    end
  end.
\end{lstlisting}
\end{minipage}

\subsection{The predicate \lstinline{ex_lfp_geq}}

We can now combine \lstinline{sub_model} and \lstinline{geq} to construct a lemma
stating that there exists a frontier \lstinline{g} that is a model of the set of clauses \lstinline{Cs}
and is greater than or equal to another frontier \lstinline{f}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:ex_lfp_geq_def}, caption={\lstinline{ex_lfp_geq} in Coq, using both \lstinline{Prop} and \lstinline{Set}}]
Definition ex_lfp_geq_P (Cs : set Clause) (V W : set string) (f : Frontier) : Prop :=
  exists g : Frontier, geq V g f = true /\ sub_model Cs V W g = true.

Definition ex_lfp_geq_S (Cs : set Clause) (V W : set string) (f : Frontier) : Set :=
  sig (fun g : Frontier => prod (geq V g f = true) (sub_model Cs V W g = true)).
\end{lstlisting}
\end{minipage}

One thing to note here is that we can define this lemma either as having the type \lstinline{Prop} or as having the type \lstinline{Set}.
When using \lstinline{Prop}, we define it as a proposition, using standard first-order logic syntax.

When using \lstinline{Set}, we define it as a type,
using the \lstinline{sig} type constructor in place of \lstinline{exists}.
We also use the \lstinline{prod} type constructor to represent the conjunction of two propositions.

Another thing to note is the difference between \lstinline{Lemma} and \lstinline{Definition}.

The reason for defining \lstinline{ex_lfp_geq} using \lstinline{Set}, is that we can then use
Coq's extraction feature to generate Haskell code from the Coq definitions.
Since \lstinline{ex_lfp_geq} plays a central part in the proof of the main theorem,
it must be defined as a \lstinline{Set} to avoid universe inconsistencies
when performing extraction.

\section{The Main Proofs}

We have now laid the groundwork for the formalization of Theorem 3.2 from the paper \cite{mbezem}.
We precede the definition of Theorem 3.2 with two additional definitions, which helps us simplify its
definition and the proof of the theorem itself.

\subsection{The predicate \lstinline{pre_thm}}

Since (in our case) the formal definitions of lemma 3.3, which will be expanded on shortly,
and theorem 3.2 share some structure, we define a predicate \lstinline{pre_thm}:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:pre_thm_def}, caption={Def. of \lstinline{pre_thm}}]
Definition pre_thm (n m : nat) (Cs : set Clause) (V W : set string) (f : Frontier) :=
  incl W V ->
  Datatypes.length (nodup string_dec V) <= n ->
  Datatypes.length
    (set_diff string_dec
      (nodup string_dec V)
      (nodup string_dec W)
    ) <= m <= n ->
  ex_lfp_geq Cs (nodup string_dec W) (nodup string_dec W) f ->
  ex_lfp_geq Cs (nodup string_dec V) (nodup string_dec V) f.
\end{lstlisting}
\end{minipage}

\subsection{Lemma 3.3}

Lemma 3.3 from the paper \cite{mbezem} is used in the proof of theorem 3.2 to solve \textcolor{red}{fill inn explanation here...}

We define it using \lstinline{pre_thm} as follows:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:lem_33}, caption={Lemma 3.3 in Coq}]
Lemma lem_33 :
  forall Cs : set Clause,
  forall V W : set string,
  forall f : Frontier,
    (forall Cs' : set Clause,
     forall V' W' : set string,
     forall f' : Frontier,
     forall m : nat,
      pre_thm (Datatypes.length (nodup string_dec V) - 1) m Cs' V' W' f'
    ) ->
    incl W V ->
    ex_lfp_geq Cs (nodup string_dec W) (nodup string_dec W) f ->
    ex_lfp_geq Cs (nodup string_dec V) (nodup string_dec W) f.
Proof.
  (* ... *)
Qed.
\end{lstlisting}
\end{minipage}

\subsection{Theorem 3.2}

We can now formulate theorem 3.2 using \lstinline{pre_thm}:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:thm_32}, caption={Theorem 3.2 in Coq}]
Theorem thm_32 :
  forall n m : nat,
  forall Cs : set Clause,
  forall V W : set string,
  forall f : Frontier,
    pre_thm n m Cs V W f.
Proof.
  (* ... *)
Qed.
\end{lstlisting}
\end{minipage}

The proof of theorem 3.2 is based on a primary induction on \lstinline{n} and a secondary induction on \lstinline{m}.

\subsubsection{Base case of \lstinline{n}}

The first base case is simple. We want to prove

(1) \tabto{2em}
\lstinline{ex_lfp_geq Cs (nodup string_dec V) (nodup string_dec V) f}.

Since \lstinline{n = 0}, we get that the length of \lstinline{V} is \lstinline{0},
and hence we get a new goal \lstinline{ex_lfp_geq Cs [] [] f}.
This is proven by the lemma \lstinline{ex_lfp_geq_empty},
which states that \lstinline{forall Cs f, ex_lfp_geq Cs [] [] f}.

\subsubsection{Inductive case of \lstinline{n}}

We start the inductive case of \lstinline{n} by doing a new induction on \lstinline{m}.

\subsubsection{Base case of \lstinline{m}}

The first base case is similar to the first base case of \lstinline{n}.
We again want to prove

\tabto{2em}
\lstinline{ex_lfp_geq Cs (nodup string_dec V) (nodup string_dec V) f}.

We now apply the lemma \lstinline{ex_lfp_geq_incl}, which states that

\tabto{2em}
\lstinline{forall Cs V W f, incl V W -> forall f, ex_lfp_geq Cs W W f -> ex_lfp_geq Cs V V f.}

We give this lemma the arguments of \lstinline{Cs}, \lstinline{nodup string_dec V} and \lstinline{nodup string_dec W}.
This generates to new goals,

$(1)$
\tabto{2em}
\lstinline{incl (nodup string_dec V) (nodup string_dec W)}

and

$(2)$
\tabto{2em}
\lstinline{ex_lfp_geq Cs (nodup string_dec W) (nodup string_dec W) f}.

The goal $(1)$ is proven by using a hypothesis that states that

\tabto{2em}
\lstinline{Datatypes.length (set_diff string_dec (nodup string_dec V) (nodup string_dec W)) <= m <= n}.

Since \lstinline{m = 0}, this means that
the set difference of \lstinline{V} and \lstinline{W} is empty.
We can now apply the lemma \lstinline{set_diff_nil_incl} on this hypothesis, which states that

\tabto{2em}
\lstinline{forall dec V W, set_diff dec V W = [] <-> incl V W.}

This gives us a hypothesis identical to our goal $(1)$, and therefore proves it.

The goal $(2)$ is proven by an existing hypothesis.

\subsubsection{Inductive case of \lstinline{m}}

\textcolor{red}{insert brief explanation here (from proof overview)...}

\section{Extraction to Haskell}

Using Coq's code extraction feature, we can extract Haskell code from our Coq definitions.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:extraction}, caption={Extraction of Coq definitions to Haskell}]
Extraction Language Haskell.

Extract Constant map => "Prelude.map".
Extract Constant fold_right => "Prelude.foldr".

Extraction "/home/user/path/to/code/ex.hs"
  thm_32
  lem_33.
\end{lstlisting}
\end{minipage}

Coq will automatically determine definitions which depend on one another when doing extraction.
In the example above, we would not have needed to specify \lstinline{lem_33} to be extracted,
since \lstinline{thm_32} already depends on it.

By default, Coq will give its own implementation of any functions used, instead of using
Haskell's native implementations. If we want, we can specify what native Haskell functions
should be used when extracting a Coq function. In the example code above,
we specify that when extracting, \lstinline[language=Haskell]{Prelude.map} and \lstinline[language=Haskell]{Prelude.foldr}
should be used for the Coq functions \lstinline{map} and \lstinline{fold_right}.

In the next chapter we will go more into detail about the results of the extraction,
and the results of the Haskell code ran on some example input.
