\chapter{Evaluation}

\section{Correctness of results from \cite{mbezem}}

As we have shown in our formalization and by the results of the
extraction, the results from \cite{mbezem} that we have formalized, appear to be correct.
As mentioned in \Cref{sec:simplifications}, we have not fully formalized nor verified the entirety of the informal proofs,
and as such we cannot be 100\% sure that the informal proof of \Cref{thm:3.2} (and related results) is correct.
However, we have verified the most important parts of \Cref{thm:3.2} without
encountering any problems, and we can thus be very confident that the informal proofs from \cite{mbezem} are correct.

\section{Feasibility of formalization}
\label{sec:feasibility_of_formalization}

The formalization of the proof of \Cref{thm:3.2} from \cite{mbezem} took us \~12 months of work.
This includes the time spent on learning Coq and the time spent on the formalization of the proof
and related lemmas/definitions.
We have shown that a formalization of the proof of \Cref{thm:3.2} is feasible,
and that is its possible to complete such a formalization in a reasonable amount of time.
It is important to remember that we did not have any prior knowledge of Coq or any other proof assistants,
and that we had to learn Coq from scratch.
The project was also not a full-time effort, and other work and studies have been done in parallel.
Given more extensive knowledge of Coq (or another other proof assistant),
and possibly more effort or man-power devoted to the project,
we believe that a formalization of a proof of a similar complexity would be a feasible task.

\textcolor{red}{I assume "we" here means "me"? you (Marc) did know Coq}

\section{Value of formalization \& extracted algorithm}

Type theory has started the transition from research to development in
the software industry, e.g. in the project CompCert \cite{compcert},
that aims to produce verified compilers for mission-critical computer systems.
A case in point of the impact of type theory on software development is the project Deep Spec
\cite{deepspec} that focuses on the specification and verification of full functional
correctness of software and hardware. The paper \cite{secpriv} in this project uses Coq to certify high-level
code for cryptographic arithmetic and yields the fastest-known elliptic-curve library in C.
This library is deployed on an industrial scale for Chrome and Android.

All these examples show that formalization has provided great value for mission-critical
systems where correctness is of utmost importance.
If we imagine our correct algorithm as a starting point for further development
and for eventual use in the Coq proof assistant for checking universe constraints,
one could argue about whether or not our case is as mission-critical as these,
as any fault in Coq as a proof assistant would taint the correctness of anything proven using it.

As seen in \Cref{sec:real_world_example}, the extracted algorithm is useful in practice,
however, the efficiency is not very good.
There are also cases where the extracted algorithm crashes, as seen in \Cref{sec:limitations}.
However, it should not be a surprise that not every case is handled by the algorithm,
as we have not given a formal proof of \Cref{lem:3.3}.
We can better think of this algorithm as a prototype or proof-of-concept,
rather than a practical algorithm.
