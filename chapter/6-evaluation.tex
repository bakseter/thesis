\chapter{Evaluation}

\section{Correctness of results from \cite{mbezem}}

As we have shown in our formalization and by the results of the
extraction, the results from \cite{mbezem} that we have formalized, appear to be correct.
As mentioned in \Cref{sec:simplifications}, we have not fully formalized nor verified the entirety of the informal proofs,
and as such we cannot be 100\% sure that the informal proof of \Cref{thm:3.2} (and related results) is correct.
However, we have verified the most important parts of \Cref{thm:3.2} without
encountering any problems, and we can thus be very confident that the informal proofs from \cite{mbezem} are correct.

\section{Feasibility of formalization}

The formalization of the proof of \Cref{thm:3.2} from \cite{mbezem} took us \~12 months of work.
This includes the time spent on learning Coq and the time spent on the formalization of the proof
and related lemmas/definitions.
We have shown that a formalization of the proof of \Cref{thm:3.2} is feasible,
and that is its possible to complete such a formalization in a reasonable amount of time.
It is important to remember that we did not have any prior knowledge of Coq or any other proof assistants,
and that we had to learn Coq from scratch.
The project was also not a full-time effort, and other work and studies have been done in parallel.
Given more extensive knowledge of Coq (or another other proof assistant),
and possibly more effort or man-power devoted to the project,
we believe that a formalization of a proof of a similar complexity would be a feasible task.

\textcolor{red}{I assume "we" here means "me"? you (Marc) did know Coq}

\section{Value of formalization effort \& extracted algorithm}

Type theory has started the transition from research to development in
the software industry, for example in the project CompCert \cite{compcert} that aims to
produce verified compilers for critical computer systems.
A case in point of the impact of type theory on software development is the project Deep Spec
\cite{deepspec} that focuses on the specification and verification of full functional
correctness of software and hardware. The paper \cite{secpriv} in this project uses Coq to certify high-level
code for cryptographic arithmetic and yields the fastest-known elliptic-curve library in C.
This library is deployed on an industrial scale for Chrome and Android.

We also gain, by the power of Coq extraction, a certified algorithm that mirrors the correctness of the proof.
As seen in \Cref{sec:real_world_example}, the extracted algorithm is useful in practice,
however, the efficiency is not very good.
There are also cases where the extracted algorithm crashes, as seen in \Cref{sec:limitations}.
However, it should not be a surprise that not every case is handled by the algorithm,
as we have not given a formal proof of \Cref{lem:3.3}.
We can better think of this algorithm as a proptype or proof-of-concept,
rather than a practical algorithm.

\textcolor{red}{quote no sick formal method shit om at correctness first -> speedy boi}
