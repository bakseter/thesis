\chapter{Background}

\section{Formalizing mathematics}

\subsection{Proofs}

When solving mathematical problems, we often use proofs
to either \textbf{justify} a claim or to \textbf{explain} why the claim is true.
We can distinguish between two types of proofs; \textit{informal} and \textit{formal} proofs.

% Traditional informal proofs emphasize the latter, and they take for grated that this is sufficent from the former.
% Formal proofs on the other hand, ??? on the former; depending on the formalism used they have some
% explanatory merit as well.

An informal proof is often written in a natural language, and the proof is adequate if most
readers are convinced by the proof \cite{bpierce}. Such proofs rely heavily on the reader's intuition
and often omit logical steps to make them easier to understand for humans \cite{ams:formal-proof}.
As these proofs grow larger and more complex, they become harder for humans to follow,
which can ultimately lead to errors in the proofs' logic. This might cause the whole proof
to be incorrect \cite{rkhamsi}, and even the claim justified by it might be wrong.

A formal proof is written in a formal language, and can be compared to a computer program
written in a programming language. Writing a formal proof is more difficult than writing an informal proof.
Formal proofs include every logical step, and nothing is left for the reader to assume.
This can make them extremely verbose, but the amount of logical errors is reduced \cite{ams:formal-proof}.
The only possible errors in formalized proofs are false assumptions and/or flawed verification software.

\section{Type theory}

Type theory groups mathematical objects with similar properties together by assigning them a "type".
Similarily to data types in computer programming, we can use types to represent mathematical
objects. For example, we can use the data type \texttt{nat} to represent natural numbers, or we can create
our own data types which allows us to represent e.g. clauses in logic.

\subsection{Propositions as types}

\textcolor{red}{add source, see LateX comment}
% https://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-types/propositions-as-types.pdf

The concept of propositions as types sees proving a mathematical proposition
as the same process as constructing a value of a type, in this case,
of the proposition as a type.
For example, to prove a proposition $P$ which states "all integers are the sum of four squares",
we must construct a value of the type $P$ that shows that this is true for all integers.
Such a value is a function that for any input $n$ returns a proof that $n$ is the sum of four squares,
that is, return four numbers $a, b, c, d$ and a proof that $n = a^2 + b^2 + c^2 + d^2$.
Proofs are mathematical objects; thus a proposition can be viewed as having the type of all its proofs (if any!).
We can use this correspondance to model a proof as a typed computer program.
The power of this concept comes from the fact that we can use a type checker to verify that
our program is typed correctly, and thus that the corresponding proof is valid.
Often, the proof can be used to compute something, i.e. the numbers $a, b, c, d$ mentioned above.

\subsection{Dependent types}

Dependent types allow us to define more rigorously types which depend on terms.

An example to illustrate this is the definition of a vector:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:dep_type_vec}, caption={\lstinline{vector} in Coq, using dependent types}]
Inductive vector (A : Type) : nat -> Type :=
  | Vnil : vector A 0
  | Vcons : forall (h : A) (n : nat), vector A n -> vector A (S n).
\end{lstlisting}
\end{minipage}

This definition gives us a type with two constructors:

\begin{itemize}
    \item
        \lstinline{Vnil} has the type of \lstinline{vector A 0}, and represents the empty vector.
    \item
        \lstinline{Vcons} has type of \lstinline{vector A (S n)}, where the value of \lstinline{n}
                            is the length of the vector given to the constructor as an argument.
                            This makes the type of a \lstinline{vector} \textit{depend} on its length.
\end{itemize}

In this scenario, the length of a \lstinline{vector} is fixed by the argument \lstinline{n : nat}
and the term \lstinline{vector A n -> vector A (S n)}.
Any definition of a \lstinline{vector} must adhere to this term, and is checked at compile time.
An example of a valid and invalid definition is:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:dep_type_vec_ex}, caption={Examples of vectors in Coq}]
(* valid definition; (S 0) equal to 1  *)
Definition vec_valid : vector string 2 :=
    Vcons string "b" 1 (Vcons string "a" 0 (Vnil string)).
(* invalid definition; (S 0) not equal to 2 *)
Definition vec_invalid : vector string 2 :=
    Vcons string "b" 2 (Vcons string "a" 0 (Vnil string)).
\end{lstlisting}
\end{minipage}

\section{Proof assistants}

Propositions as types allow us to bridge the gap between logic and computing,
while dependent types allow us to define more rigorously types which depends on values.
The former is a crucial aspect of \textit{proof assistants}, while the latter gives
us more expressive power when constructing proofs using a proof assistant.
An example of the expressive power of dependent types is the fact that we can define
predicates that depend on the value of a term, e.g. a predicate that checks if a number is even.
The purpose of a proof assistant is to get computer support for continuity and verify a formal proof mechanically.

\subsection{Coq}
Coq is based on the higher-order type theory \textit{Calculus of Inductive Constructions} (CIC), and
functions as both a proof assistant and a dependently typed functional programming language.
Coq also allow us to extract certified programs from the proofs of their specification to
the programming langauges OCaml and Haskell \cite{cintro}.
Coq implements a specification language called \textit{Gallina},
which allows us to define logical objects within Coq.
These objects are typed to ensure their correctness \textcolor{red}{(is quote too direct?)},
and the typing rules used are from CIC \cite{cic}.

This is an example of the syntax of Gallina:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:gallina_ex}, caption={Example of Gallina syntax}]
Inductive nat : Type :=
  | O
  | S : nat -> nat.

Definition lt_n_S_n :=
  (fun n : nat => le_n (S n)) : forall n : nat, n < S n.
\end{lstlisting}
\end{minipage}

Looking at the final definition in the example, we can see the
concept of propositions as types in action.
\lstinline{lt_n_S_n} defines a function which takes a natural number \lstinline{n}
as input, and returns a value of the type \lstinline{forall n : nat, n < S n},
denoted by the colon before the type itself.
The return value is therefore a proof of \lstinline{forall n : nat, n < S n}, and since
the definition has been type-checked by Coq, we know that this proof is valid!
In this case, the function is
\lstinline{fun : nat => le_s (S n)}, where \lstinline{le_n} is a constructor
of the type \lstinline{forall n : nat, n <= n}. By applying this constructor
to \lstinline{S n}, we get a value of the type (and a proof) of
\lstinline{forall n : nat, S n <= S n}. By Coq's definition of \lstinline{<},
our initial theorem can be rewritten as \lstinline{forall n : nat, S n <= S n}.
This matches the type of our function, and the proof is complete.

Proving theorems like this is not really intuitive for a human prover,
and that is why Coq gives us the \textit{Ltac} meta-language for writing proofs.
Ltac provides us with tactics, which are a kind of shorthand syntax for defining Gallina terms \textcolor{red}{(is this correct?)} \cite{cltac}.
Using Ltac, we can rewrite the proof from \ref{lst:gallina_ex} as such:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:ltac_ex}, caption={Example of Ltac syntax}]
Theorem lt_n_S_n : forall n : nat, n < S n.
Proof.
  intro n. destruct n.
  - apply le_n.
  - apply le_n_S. apply le_n.
Qed.
\end{lstlisting}
\end{minipage}

When developing proofs using Ltac, each tactic is executed or "played" one by one,
much like an interpreter. The tactics are seperated by punctuation marks.
When the use of a tactic causes the proof to depend on the solving of multiple sub-proofs (called "goals"),
we can use symbols like "-", "+", and "*" to branch into these sub-proofs and solve their goals independently.
Once a goal has been solved, we can move on the next. When there are no more goals, the proof is complete.
Coq provides us with tooling that gives us the ability to see our goals and the proof state
to further simplify the process \cite{cide}.
Ltac is not the only proof langauge, with another example being \textit{SSReflect} \cite{cssr}.

\subsection{Other proof assistants}

\subsubsection{Agda}

Agda is a depdently typed functional programming language based on Martin-Löf's
intuitionistic type theory. Unlike Coq, Agda does not use tactics. \cite{agdatut}
However, by using proposition as types, Agda can also function as a proof assistant.

\subsubsection{Isabelle}

\subsubsection{Lean}

Lean is proof assistant, automated theorem prover and dependently typed functional programming language.
Lean can be instantiated using either CIC or Martin-Löf's intuitionistic type theory.
\cite{lean}

\subsubsection{Higher-Order Logic}

\subsection{Extraction of programs from verified proofs}

By the the notion of propositions as types, we can use a proof assistant to
prove the correctness of a program. However, we can also extract a program from
a proof of its correctness. This type of code extraction is a common feature of proof assistants.
The extracted program is guaranteed to be correct by the type system of the proof assistant,
and the resulting code can be extracted to a variety programming languages, such as Haskell and OCaml (as is the case for Coq).
\cite{cintro}


\textcolor{red}{(if we want to elaborate, cite this \url{https://www.irif.fr/~letouzey/download/extraction2002.pdf} and this \url{https://www.irif.fr/~letouzey/download/letouzey_extr_cie08.pdf})}
