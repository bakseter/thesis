\chapter{Background}
\label{ch:background}

\section{Proofs \& formalization}
\label{sec:proofs_formalization}

When solving mathematical problems, we often use proofs
to either \textbf{justify} a claim or to \textbf{explain} why the claim is true.
We can distinguish between two types of proofs; \emph{informal} and \emph{formal} proofs.

An informal proof is often written in a natural language, and the proof is adequate if most
readers are convinced by the proof \cite{bpierce}. Such proofs rely heavily on the reader's intuition
and often omit logical steps to make them easier to understand for humans \cite{ams:formal-proof}.
As these proofs grow larger and more complex, they become harder for humans to follow,
which can ultimately lead to errors in the proofs' logic. This might cause the whole proof
to be incorrect \cite{rkhamsi}, and even the claim justified by the proof might be wrong.

A formal proof is written in a formal language, and can be compared to a computer program
written in a programming language. Writing a formal proof is more difficult than writing an informal proof.
Formal proofs include every logical step, and nothing is left for the reader to assume.
This can formal proofs extremely verbose, but the amount of logical errors is reduced \cite{ams:formal-proof}.
The only possible errors in formalized proofs are false assumptions and/or flawed verification software.
When we talk about \emph{formalization}, we mean the process of translating an informal proof into a formal proof.

\section{Type theory}
\label{sec:type_theory}

Type theory groups mathematical objects with similar properties together by assigning them a "type".
Similarly to data types in computer programming, we can use types to represent mathematical
objects. For example, we can use the data type \texttt{nat} to represent natural numbers, or we can create
our own data types which allows us to represent e.g., clauses in logic.

\subsection{Propositions as types}
\label{ssec:propositions_as_types}

The concept of propositions as types sees proving a mathematical proposition
as the same process as constructing a value of a type, in this case,
of the proposition as a type.
For example, to prove a proposition $P$ which states "all natural numbers are the sum of four squares",
we must construct a value of the type $P$ that shows that this is true for all natural numbers.
Such a value is a function that for any input $n$ returns a proof that $n$ is the sum of four squares,
that is, return four numbers $a, b, c, d$ and a proof that $n = a^2 + b^2 + c^2 + d^2$.
Proofs are mathematical objects; thus a proposition can be viewed as having the type of all its proofs (if any!).
We can use this correspondence to model a proof as a typed computer program.
The power of this concept comes from the fact that we can use a type checker to verify that
our program is typed correctly, and thus that the corresponding proof is valid.
Often, the proof can be used to compute something, i.e., the numbers $a, b, c, d$ mentioned above
\cite{pwadler}.

\subsection{Dependent types}
\label{ssec:dependent_types}

Dependent types allow us to define more rigorously types that depend on values.
This is important for propositions as types.
For example, the proposition $P$ in \Cref{ssec:propositions_as_types} uses
$n = a^2 + b^2 + c^2 + d^2$, which is a type depending on five values $n, a, b, c, d$.
Since Coq has support for dependent types, we can give an example to illustrate what this means.
We consider the type \lstinline{vector}, which is a type polymorphic (the elements of the list can be of any same type)
finite list with a fixed length, which is the value on which the type depends, a natural number.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:dep_type_vec}, caption={\lstinline{vector} in Coq, using dependent types}]
Inductive vector (A : Type) : nat -> Type :=
  | Vnil : vector A 0
  | Vcons : forall (h : A) (n : nat), vector A n -> vector A (S n).
\end{lstlisting}
\end{minipage}

This definition gives us a type with two constructors:

\begin{itemize}
    \item
        \lstinline{Vnil} has the type of \lstinline{vector A 0}, and represents the empty vector.
    \item
        \lstinline{Vcons} has type of \lstinline{forall (h : A) (n : nat) vector A (S n)}, where \lstinline{h}
                            is the head of the vector and \lstinline{n} is the length of the vector,
                            where both are given to the constructor as arguments.
                            This makes the type of a \lstinline{vector} \emph{depend} on its length.
\end{itemize}

In this scenario, the length of a \lstinline{vector} is fixed by the argument \lstinline{n : nat}
and the term \lstinline{vector A n -> vector A (S n)}.
Any definition of a \lstinline{vector} must adhere to this term, and is checked at compile time.
An example of a valid and invalid definition is:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:dep_type_vec_ex}, caption={Examples of vectors in Coq}]
(* valid definition; (S 0) equal to 1  *)
Definition vec_valid : vector string 2 :=
    Vcons string "b" 1 (Vcons string "a" 0 (Vnil string)).
(* invalid definition; (S 0) not equal to 2 *)
Fail Definition vec_invalid : vector string 2 :=
    Vcons string "b" 2 (Vcons string "a" 0 (Vnil string)).
\end{lstlisting}
\end{minipage}

\section{Proof assistants}
\label{sec:proof_assistants}

Propositions as types allow us to bridge the gap between logic and computing,
while dependent types allow us to define more rigorously types which depend on values,
thus enhancing the expressivity of simple types.
The former is a crucial aspect of \emph{proof assistants}, while the latter gives
us more expressive power when constructing proofs using a proof assistant.
An example of the expressive power of dependent types is the fact that we can define
predicates that depend on the value of a term, e.g. a predicate that checks if a number is even.
The purpose of a proof assistant is to get computer support to construct and verify a formal proof mechanically.

\subsection{Coq}
\label{ssec:coq}

Coq is based on the higher-order type theory \emph{Calculus of Inductive Constructions} (CIC), and
functions as both a proof assistant and a dependently typed functional programming language.
Coq also allow us to extract certified programs from the proofs of their specification to
the programming languages OCaml and Haskell \cite{cintro}.
Coq implements a specification language called \emph{Gallina},
which allows us to define logical objects within Coq.
These objects are typed to ensure their correctness \textcolor{red}{(is quote too direct?)},
and the typing rules used are from CIC \cite{cic}.

This is an example of the syntax of Gallina:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:gallina_ex}, caption={Example of Gallina syntax}]
Inductive nat : Type :=
  | O
  | S : nat -> nat.

Definition lt_n_S_n :=
  (fun n : nat => le_n (S n)) : forall n : nat, n < S n.
\end{lstlisting}
\end{minipage}

Looking at the final definition in the example, we can see the
concept of propositions as types in action.
\lstinline{lt_n_S_n} defines a function which takes a natural number \lstinline{n}
as input, and returns a value of the type \lstinline{forall n : nat, n < S n},
denoted by the colon before the type itself.
The return value is therefore a proof of \lstinline{forall n : nat, n < S n}, and since
the definition has been type-checked by Coq, we know that this proof is valid!
In this case, the function is
\lstinline{fun : nat => le_s (S n)}, where \lstinline{le_n} is a constructor
of the type \lstinline{forall n : nat, n <= n}. By applying this constructor
to \lstinline{S n}, we get a value of the type (and a proof) of
\lstinline{forall n : nat, S n <= S n}.
By Coq's definition of \lstinline{<},
our initial theorem can be rewritten as \lstinline{forall n : nat, S n <= S n}.
This matches the type of our function, and the proof is complete.

Proving theorems like this is not really intuitive for a human prover,
and that is why Coq gives us the \emph{Ltac} meta-language for writing proofs.
Ltac provides us with tactics, which are a kind of shorthand syntax for defining Gallina terms \cite{cltac}.
Using Ltac, we can rewrite the proof from \ref{lst:gallina_ex} as such:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Coq, label={lst:ltac_ex}, caption={Example of Ltac syntax}]
Theorem lt_n_S_n : forall n : nat, n < S n.
Proof.
  intro n. destruct n.
  - apply le_n.
  - apply le_n_S. apply le_n.
Qed.
\end{lstlisting}
\end{minipage}

When developing proofs using Ltac, each tactic is executed or "played" one by one,
much like an interpreter. The tactics are separated by punctuation marks.
When the use of a tactic causes the proof to depend on the solving of multiple sub-proofs (called "goals"),
we can use symbols like "-", "+", and "*" to branch into these sub-proofs and solve their goals independently.
Once a goal has been solved, we can move on the next. When there are no more goals, the proof is complete.
Coq provides us with tooling that gives us the ability to see our goals and the proof state
to further simplify the process \cite{cide}.
Ltac is not the only proof language, with another example being \emph{SSReflect} \cite{cssr}.

\subsection{Other proof assistants}
\label{ssec:other_proof_assistants}

\subsubsection{Agda}
\label{sssec:agda}

Agda is a dependently typed functional programming language based on Martin-LÃ¶f's
intuitionistic type theory. Unlike Coq, Agda does not use tactics
However, by using proposition as types, Agda can also function as a proof assistant
\cite{agdatut}.

\subsubsection{Isabelle}
\label{sssec:isabelle}

\subsubsection{Lean}
\label{sssec:lean}

Lean is dependently typed functional programming language and theorem prover.
The goal of Lean is to establish a connection between the automated and interactive processes of proving theorems.
Like Coq, Lean is also based on the type theory of CIC
\cite{lean}.

\subsubsection{Higher-Order Logic}
\label{sssec:hol}

HOL is a family of several theorem provers, based on the concept of higher-order logic.

\subsection{Extraction of programs from verified proofs}
\label{ssec:extraction_of_programs_from_verified_proofs}

By the the notion of propositions as types, we can use a proof assistant to
prove the correctness of a program. However, we can also extract a program from
a proof of its correctness. This type of code extraction is a common feature of proof assistants.
The extracted program is guaranteed to be correct by the type system of the proof assistant,
and the resulting code can be extracted to several programming languages, such as Haskell and OCaml (as is the case for Coq) \cite{cintro}.
